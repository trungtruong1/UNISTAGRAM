{"ast":null,"code":"/*\r\n * Copyright (c) 2021, Jeff Hlywa (jhlywa@gmail.com)\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n *----------------------------------------------------------------------------*/\nexport default function Chess(fen) {\n  var BLACK = 'b';\n  var WHITE = 'w';\n  var EMPTY = -1;\n  var PAWN = 'p';\n  var KNIGHT = 'n';\n  var BISHOP = 'b';\n  var ROOK = 'r';\n  var QUEEN = 'q';\n  var KING = 'k';\n  var SYMBOLS = 'pnbrqkPNBRQK';\n  var DEFAULT_POSITION = 'ppppkppp/pppppppp/8/8/8/8/PPPPPPPP/PPPPKPPP w - - 0 1';\n  var TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n  var PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15]\n  };\n  var PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1]\n  }; // prettier-ignore\n\n  var ATTACKS = [20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20]; // prettier-ignore\n\n  var RAYS = [17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17];\n  var SHIFTS = {\n    p: 0,\n    n: 1,\n    b: 2,\n    r: 3,\n    q: 4,\n    k: 5\n  };\n  var FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q'\n  };\n  var BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64\n  };\n  var RANK_1 = 7;\n  var RANK_2 = 6;\n  var RANK_3 = 5;\n  var RANK_4 = 4;\n  var RANK_5 = 3;\n  var RANK_6 = 2;\n  var RANK_7 = 1;\n  var RANK_8 = 0; // prettier-ignore\n\n  var SQUARES = {\n    a8: 0,\n    b8: 1,\n    c8: 2,\n    d8: 3,\n    e8: 4,\n    f8: 5,\n    g8: 6,\n    h8: 7,\n    a7: 16,\n    b7: 17,\n    c7: 18,\n    d7: 19,\n    e7: 20,\n    f7: 21,\n    g7: 22,\n    h7: 23,\n    a6: 32,\n    b6: 33,\n    c6: 34,\n    d6: 35,\n    e6: 36,\n    f6: 37,\n    g6: 38,\n    h6: 39,\n    a5: 48,\n    b5: 49,\n    c5: 50,\n    d5: 51,\n    e5: 52,\n    f5: 53,\n    g5: 54,\n    h5: 55,\n    a4: 64,\n    b4: 65,\n    c4: 66,\n    d4: 67,\n    e4: 68,\n    f4: 69,\n    g4: 70,\n    h4: 71,\n    a3: 80,\n    b3: 81,\n    c3: 82,\n    d3: 83,\n    e3: 84,\n    f3: 85,\n    g3: 86,\n    h3: 87,\n    a2: 96,\n    b2: 97,\n    c2: 98,\n    d2: 99,\n    e2: 100,\n    f2: 101,\n    g2: 102,\n    h2: 103,\n    a1: 112,\n    b1: 113,\n    c1: 114,\n    d1: 115,\n    e1: 116,\n    f1: 117,\n    g1: 118,\n    h1: 119\n  };\n  var ROOKS = {\n    w: [{\n      square: SQUARES.a1,\n      flag: BITS.QSIDE_CASTLE\n    }, {\n      square: SQUARES.h1,\n      flag: BITS.KSIDE_CASTLE\n    }],\n    b: [{\n      square: SQUARES.a8,\n      flag: BITS.QSIDE_CASTLE\n    }, {\n      square: SQUARES.h8,\n      flag: BITS.KSIDE_CASTLE\n    }]\n  };\n  var board = new Array(128);\n  var kings = {\n    w: EMPTY,\n    b: EMPTY\n  };\n  var turn = WHITE;\n  var castling = {\n    w: 0,\n    b: 0\n  };\n  var ep_square = EMPTY;\n  var half_moves = 0;\n  var move_number = 1;\n  var history = [];\n  var header = {};\n  var comments = {};\n  /* if the user passes in a fen string, load it, else default to\r\n   * starting position\r\n   */\n\n  if (typeof fen === 'undefined') {\n    load(DEFAULT_POSITION);\n  } else {\n    load(fen);\n  }\n\n  function clear(keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false;\n    }\n\n    board = new Array(128);\n    kings = {\n      w: EMPTY,\n      b: EMPTY\n    };\n    turn = WHITE;\n    castling = {\n      w: 0,\n      b: 0\n    };\n    ep_square = EMPTY;\n    half_moves = 0;\n    move_number = 1;\n    history = [];\n    if (!keep_headers) header = {};\n    comments = {};\n    update_setup(generate_fen());\n  }\n\n  function prune_comments() {\n    var reversed_history = [];\n    var current_comments = {};\n\n    var copy_comment = function (fen) {\n      if (fen in comments) {\n        current_comments[fen] = comments[fen];\n      }\n    };\n\n    while (history.length > 0) {\n      reversed_history.push(undo_move());\n    }\n\n    copy_comment(generate_fen());\n\n    while (reversed_history.length > 0) {\n      make_move(reversed_history.pop());\n      copy_comment(generate_fen());\n    }\n\n    comments = current_comments;\n  }\n\n  function reset() {\n    load(DEFAULT_POSITION);\n  }\n\n  function load(fen, keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false;\n    }\n\n    var tokens = fen.split(/\\s+/);\n    var position = tokens[0];\n    var square = 0;\n\n    if (!validate_fen(fen).valid) {\n      return false;\n    }\n\n    clear(keep_headers);\n\n    for (var i = 0; i < position.length; i++) {\n      var piece = position.charAt(i);\n\n      if (piece === '/') {\n        square += 8;\n      } else if (is_digit(piece)) {\n        square += parseInt(piece, 10);\n      } else {\n        var color = piece < 'a' ? WHITE : BLACK;\n        put({\n          type: piece.toLowerCase(),\n          color: color\n        }, algebraic(square));\n        square++;\n      }\n    }\n\n    turn = tokens[1];\n\n    if (tokens[2].indexOf('K') > -1) {\n      castling.w |= BITS.KSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('Q') > -1) {\n      castling.w |= BITS.QSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('k') > -1) {\n      castling.b |= BITS.KSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('q') > -1) {\n      castling.b |= BITS.QSIDE_CASTLE;\n    }\n\n    ep_square = tokens[3] === '-' ? EMPTY : SQUARES[tokens[3]];\n    half_moves = parseInt(tokens[4], 10);\n    move_number = parseInt(tokens[5], 10);\n    update_setup(generate_fen());\n    return true;\n  }\n  /* TODO: this function is pretty much crap - it validates structure but\r\n   * completely ignores content (e.g. doesn't verify that each side has a king)\r\n   * ... we should rewrite this, and ditch the silly error_number field while\r\n   * we're at it\r\n   */\n\n\n  function validate_fen(fen) {\n    var errors = {\n      0: 'No errors.',\n      1: 'FEN string must contain six space-delimited fields.',\n      2: '6th field (move number) must be a positive integer.',\n      3: '5th field (half move counter) must be a non-negative integer.',\n      4: '4th field (en-passant square) is invalid.',\n      5: '3rd field (castling availability) is invalid.',\n      6: '2nd field (side to move) is invalid.',\n      7: \"1st field (piece positions) does not contain 8 '/'-delimited rows.\",\n      8: '1st field (piece positions) is invalid [consecutive numbers].',\n      9: '1st field (piece positions) is invalid [invalid piece].',\n      10: '1st field (piece positions) is invalid [row too large].',\n      11: 'Illegal en-passant square'\n    };\n    /* 1st criterion: 6 space-seperated fields? */\n\n    var tokens = fen.split(/\\s+/);\n\n    if (tokens.length !== 6) {\n      return {\n        valid: false,\n        error_number: 1,\n        error: errors[1]\n      };\n    }\n    /* 2nd criterion: move number field is a integer value > 0? */\n\n\n    if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) {\n      return {\n        valid: false,\n        error_number: 2,\n        error: errors[2]\n      };\n    }\n    /* 3rd criterion: half move counter is an integer >= 0? */\n\n\n    if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) {\n      return {\n        valid: false,\n        error_number: 3,\n        error: errors[3]\n      };\n    }\n    /* 4th criterion: 4th field is a valid e.p.-string? */\n\n\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n      return {\n        valid: false,\n        error_number: 4,\n        error: errors[4]\n      };\n    }\n    /* 5th criterion: 3th field is a valid castle-string? */\n\n\n    if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n      return {\n        valid: false,\n        error_number: 5,\n        error: errors[5]\n      };\n    }\n    /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n\n\n    if (!/^(w|b)$/.test(tokens[1])) {\n      return {\n        valid: false,\n        error_number: 6,\n        error: errors[6]\n      };\n    }\n    /* 7th criterion: 1st field contains 8 rows? */\n\n\n    var rows = tokens[0].split('/');\n\n    if (rows.length !== 8) {\n      return {\n        valid: false,\n        error_number: 7,\n        error: errors[7]\n      };\n    }\n    /* 8th criterion: every row is valid? */\n\n\n    for (var i = 0; i < rows.length; i++) {\n      /* check for right sum of fields AND not two numbers in succession */\n      var sum_fields = 0;\n      var previous_was_number = false;\n\n      for (var k = 0; k < rows[i].length; k++) {\n        if (!isNaN(rows[i][k])) {\n          if (previous_was_number) {\n            return {\n              valid: false,\n              error_number: 8,\n              error: errors[8]\n            };\n          }\n\n          sum_fields += parseInt(rows[i][k], 10);\n          previous_was_number = true;\n        } else {\n          if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n            return {\n              valid: false,\n              error_number: 9,\n              error: errors[9]\n            };\n          }\n\n          sum_fields += 1;\n          previous_was_number = false;\n        }\n      }\n\n      if (sum_fields !== 8) {\n        return {\n          valid: false,\n          error_number: 10,\n          error: errors[10]\n        };\n      }\n    }\n\n    if (tokens[3][1] == '3' && tokens[1] == 'w' || tokens[3][1] == '6' && tokens[1] == 'b') {\n      return {\n        valid: false,\n        error_number: 11,\n        error: errors[11]\n      };\n    }\n    /* everything's okay! */\n\n\n    return {\n      valid: true,\n      error_number: 0,\n      error: errors[0]\n    };\n  }\n\n  function generate_fen() {\n    var empty = 0;\n    var fen = '';\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      if (board[i] == null) {\n        empty++;\n      } else {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n\n        var color = board[i].color;\n        var piece = board[i].type;\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n      }\n\n      if (i + 1 & 0x88) {\n        if (empty > 0) {\n          fen += empty;\n        }\n\n        if (i !== SQUARES.h1) {\n          fen += '/';\n        }\n\n        empty = 0;\n        i += 8;\n      }\n    }\n\n    var cflags = '';\n\n    if (castling[WHITE] & BITS.KSIDE_CASTLE) {\n      cflags += 'K';\n    }\n\n    if (castling[WHITE] & BITS.QSIDE_CASTLE) {\n      cflags += 'Q';\n    }\n\n    if (castling[BLACK] & BITS.KSIDE_CASTLE) {\n      cflags += 'k';\n    }\n\n    if (castling[BLACK] & BITS.QSIDE_CASTLE) {\n      cflags += 'q';\n    }\n    /* do we have an empty castling flag? */\n\n\n    cflags = cflags || '-';\n    var epflags = ep_square === EMPTY ? '-' : algebraic(ep_square);\n    return [fen, turn, cflags, epflags, half_moves, move_number].join(' ');\n  }\n\n  function set_header(args) {\n    for (var i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        header[args[i]] = args[i + 1];\n      }\n    }\n\n    return header;\n  }\n  /* called when the initial board setup is changed with put() or remove().\r\n   * modifies the SetUp and FEN properties of the header object.  if the FEN is\r\n   * equal to the default position, the SetUp and FEN are deleted\r\n   * the setup is only updated if history.length is zero, ie moves haven't been\r\n   * made.\r\n   */\n\n\n  function update_setup(fen) {\n    if (history.length > 0) return;\n\n    if (fen !== DEFAULT_POSITION) {\n      header['SetUp'] = '1';\n      header['FEN'] = fen;\n    } else {\n      delete header['SetUp'];\n      delete header['FEN'];\n    }\n  }\n\n  function get(square) {\n    var piece = board[SQUARES[square]];\n    return piece ? {\n      type: piece.type,\n      color: piece.color\n    } : null;\n  }\n\n  function put(piece, square) {\n    /* check for valid piece object */\n    if (!('type' in piece && 'color' in piece)) {\n      return false;\n    }\n    /* check for piece */\n\n\n    if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\n      return false;\n    }\n    /* check for valid square */\n\n\n    if (!(square in SQUARES)) {\n      return false;\n    }\n\n    var sq = SQUARES[square];\n    /* don't let the user place more than one king */\n\n    if (piece.type == KING && !(kings[piece.color] == EMPTY || kings[piece.color] == sq)) {\n      return false;\n    }\n\n    board[sq] = {\n      type: piece.type,\n      color: piece.color\n    };\n\n    if (piece.type === KING) {\n      kings[piece.color] = sq;\n    }\n\n    update_setup(generate_fen());\n    return true;\n  }\n\n  function remove(square) {\n    var piece = get(square);\n    board[SQUARES[square]] = null;\n\n    if (piece && piece.type === KING) {\n      kings[piece.color] = EMPTY;\n    }\n\n    update_setup(generate_fen());\n    return piece;\n  }\n\n  function build_move(board, from, to, flags, promotion) {\n    var move = {\n      color: turn,\n      from: from,\n      to: to,\n      flags: flags,\n      piece: board[from].type\n    };\n\n    if (promotion) {\n      move.flags |= BITS.PROMOTION;\n      move.promotion = promotion;\n    }\n\n    if (board[to]) {\n      move.captured = board[to].type;\n    } else if (flags & BITS.EP_CAPTURE) {\n      move.captured = PAWN;\n    }\n\n    return move;\n  }\n\n  function generate_moves(options) {\n    function add_move(board, moves, from, to, flags) {\n      /* if pawn promotion */\n      if (board[from].type === PAWN && (rank(to) === RANK_8 || rank(to) === RANK_1)) {\n        var pieces = [QUEEN, ROOK, BISHOP, KNIGHT];\n\n        for (var i = 0, len = pieces.length; i < len; i++) {\n          moves.push(build_move(board, from, to, flags, pieces[i]));\n        }\n      } else {\n        moves.push(build_move(board, from, to, flags));\n      }\n    }\n\n    var moves = [];\n    var us = turn;\n    var them = swap_color(us);\n    var second_rank = {\n      b: RANK_7,\n      w: RANK_2\n    };\n    var first_sq = SQUARES.a8;\n    var last_sq = SQUARES.h1;\n    var single_square = false;\n    /* do we want legal moves? */\n\n    var legal = typeof options !== 'undefined' && 'legal' in options ? options.legal : true;\n    var piece_type = typeof options !== 'undefined' && 'piece' in options && typeof options.piece === 'string' ? options.piece.toLowerCase() : true;\n    /* are we generating moves for a single square? */\n\n    if (typeof options !== 'undefined' && 'square' in options) {\n      if (options.square in SQUARES) {\n        first_sq = last_sq = SQUARES[options.square];\n        single_square = true;\n      } else {\n        /* invalid square */\n        return [];\n      }\n    }\n\n    for (var i = first_sq; i <= last_sq; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n\n      var piece = board[i];\n\n      if (piece == null || piece.color !== us) {\n        continue;\n      }\n\n      if (piece.type === PAWN && (piece_type === true || piece_type === PAWN)) {\n        /* single square, non-capturing */\n        var square = i + PAWN_OFFSETS[us][0];\n\n        if (board[square] == null) {\n          add_move(board, moves, i, square, BITS.NORMAL);\n          /* double square */\n\n          var square = i + PAWN_OFFSETS[us][1];\n\n          if (second_rank[us] === rank(i) && board[square] == null) {\n            add_move(board, moves, i, square, BITS.BIG_PAWN);\n          }\n        }\n        /* pawn captures */\n\n\n        for (j = 2; j < 4; j++) {\n          var square = i + PAWN_OFFSETS[us][j];\n          if (square & 0x88) continue;\n\n          if (board[square] != null && board[square].color === them) {\n            add_move(board, moves, i, square, BITS.CAPTURE);\n          } else if (square === ep_square) {\n            add_move(board, moves, i, ep_square, BITS.EP_CAPTURE);\n          }\n        }\n      } else if (piece_type === true || piece_type === piece.type) {\n        for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {\n          var offset = PIECE_OFFSETS[piece.type][j];\n          var square = i;\n\n          while (true) {\n            square += offset;\n            if (square & 0x88) break;\n\n            if (board[square] == null) {\n              add_move(board, moves, i, square, BITS.NORMAL);\n            } else {\n              if (board[square].color === us) break;\n              add_move(board, moves, i, square, BITS.CAPTURE);\n              break;\n            }\n            /* break, if knight or king */\n\n\n            if (piece.type === 'n' || piece.type === 'k') break;\n          }\n        }\n      }\n    }\n    /* check for castling if: a) we're generating all moves, or b) we're doing\r\n     * single square move generation on the king's square\r\n     */\n\n\n    if (piece_type === true || piece_type === KING) {\n      if (!single_square || last_sq === kings[us]) {\n        /* king-side castling */\n        if (castling[us] & BITS.KSIDE_CASTLE) {\n          var castling_from = kings[us];\n          var castling_to = castling_from + 2;\n\n          if (board[castling_from + 1] == null && board[castling_to] == null && !attacked(them, kings[us]) && !attacked(them, castling_from + 1) && !attacked(them, castling_to)) {\n            add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE);\n          }\n        }\n        /* queen-side castling */\n\n\n        if (castling[us] & BITS.QSIDE_CASTLE) {\n          var castling_from = kings[us];\n          var castling_to = castling_from - 2;\n\n          if (board[castling_from - 1] == null && board[castling_from - 2] == null && board[castling_from - 3] == null && !attacked(them, kings[us]) && !attacked(them, castling_from - 1) && !attacked(them, castling_to)) {\n            add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE);\n          }\n        }\n      }\n    }\n    /* return all pseudo-legal moves (this includes moves that allow the king\r\n     * to be captured)\r\n     */\n\n\n    if (!legal) {\n      return moves;\n    }\n    /* filter out illegal moves */\n\n\n    var legal_moves = [];\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i]);\n\n      if (!king_attacked(us)) {\n        legal_moves.push(moves[i]);\n      }\n\n      undo_move();\n    }\n\n    return legal_moves;\n  }\n\n  function end_turn() {\n    turn = swap_color(turn);\n  }\n  /* convert a move from 0x88 coordinates to Standard Algebraic Notation\r\n   * (SAN)\r\n   *\r\n   * @param {boolean} sloppy Use the sloppy SAN generator to work around over\r\n   * disambiguation bugs in Fritz and Chessbase.  See below:\r\n   *\r\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\r\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\r\n   * 4. ... Ne7 is technically the valid SAN\r\n   */\n\n\n  function move_to_san(move, moves) {\n    var output = '';\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O';\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O';\n    } else {\n      if (move.piece !== PAWN) {\n        var disambiguator = get_disambiguator(move, moves);\n        output += move.piece.toUpperCase() + disambiguator;\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0];\n        }\n\n        output += 'x';\n      }\n\n      output += algebraic(move.to);\n\n      if (move.flags & BITS.PROMOTION) {\n        output += '=' + move.promotion.toUpperCase();\n      }\n    }\n\n    make_move(move);\n\n    if (in_check()) {\n      if (in_checkmate()) {\n        output += '#';\n      } else {\n        output += '+';\n      }\n    }\n\n    undo_move();\n    return output;\n  } // parses all of the decorators out of a SAN string\n\n\n  function stripped_san(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n  }\n\n  function attacked(color, square) {\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      /* if empty square or wrong color */\n\n\n      if (board[i] == null || board[i].color !== color) continue;\n      var piece = board[i];\n      var difference = i - square;\n      var index = difference + 119;\n\n      if (ATTACKS[index] & 1 << SHIFTS[piece.type]) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true;\n          } else {\n            if (piece.color === BLACK) return true;\n          }\n\n          continue;\n        }\n        /* if the piece is a knight or a king */\n\n\n        if (piece.type === 'n' || piece.type === 'k') return true;\n        var offset = RAYS[index];\n        var j = i + offset;\n        var blocked = false;\n\n        while (j !== square) {\n          if (board[j] != null) {\n            blocked = true;\n            break;\n          }\n\n          j += offset;\n        }\n\n        if (!blocked) return true;\n      }\n    }\n\n    return false;\n  }\n\n  function king_attacked(color) {\n    return attacked(swap_color(color), kings[color]);\n  }\n\n  function in_check() {\n    return king_attacked(turn);\n  }\n\n  function in_checkmate() {\n    return in_check() && generate_moves().length === 0 || !/(.*k.*)(.*K.*)*/.test(generate_fen());\n  }\n\n  function in_stalemate() {\n    return !in_check() && generate_moves().length === 0;\n  }\n\n  function insufficient_material() {\n    var pieces = {};\n    var bishops = [];\n    var num_pieces = 0;\n    var sq_color = 0;\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      sq_color = (sq_color + 1) % 2;\n\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n\n      var piece = board[i];\n\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n\n        if (piece.type === BISHOP) {\n          bishops.push(sq_color);\n        }\n\n        num_pieces++;\n      }\n    }\n    /* k vs. k */\n\n\n    if (num_pieces === 2) {\n      return true;\n    } else if (\n    /* k vs. kn .... or .... k vs. kb */\n    num_pieces === 3 && (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n      return true;\n    } else if (num_pieces === pieces[BISHOP] + 2) {\n      /* kb vs. kb where any number of bishops are all on the same color */\n      var sum = 0;\n      var len = bishops.length;\n\n      for (var i = 0; i < len; i++) {\n        sum += bishops[i];\n      }\n\n      if (sum === 0 || sum === len) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function in_threefold_repetition() {\n    /* TODO: while this function is fine for casual use, a better\r\n     * implementation would use a Zobrist key (instead of FEN). the\r\n     * Zobrist key would be maintained in the make_move/undo_move functions,\r\n     * avoiding the costly that we do below.\r\n     */\n    var moves = [];\n    var positions = {};\n    var repetition = false;\n\n    while (true) {\n      var move = undo_move();\n      if (!move) break;\n      moves.push(move);\n    }\n\n    while (true) {\n      /* remove the last two fields in the FEN string, they're not needed\r\n       * when checking for draw by rep */\n      var fen = generate_fen().split(' ').slice(0, 4).join(' ');\n      /* has the position occurred three or move times */\n\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n\n      if (positions[fen] >= 3) {\n        repetition = true;\n      }\n\n      if (!moves.length) {\n        break;\n      }\n\n      make_move(moves.pop());\n    }\n\n    return repetition;\n  }\n\n  function push(move) {\n    history.push({\n      move: move,\n      kings: {\n        b: kings.b,\n        w: kings.w\n      },\n      turn: turn,\n      castling: {\n        b: castling.b,\n        w: castling.w\n      },\n      ep_square: ep_square,\n      half_moves: half_moves,\n      move_number: move_number\n    });\n  }\n\n  function make_move(move) {\n    var us = turn;\n    var them = swap_color(us);\n    push(move);\n    board[move.to] = board[move.from];\n    board[move.from] = null;\n    /* if ep capture, remove the captured pawn */\n\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (turn === BLACK) {\n        board[move.to - 16] = null;\n      } else {\n        board[move.to + 16] = null;\n      }\n    }\n    /* if pawn promotion, replace with new piece */\n\n\n    if (move.flags & BITS.PROMOTION) {\n      board[move.to] = {\n        type: move.promotion,\n        color: us\n      };\n    }\n    /* if we moved the king */\n\n\n    if (board[move.to].type === KING) {\n      kings[board[move.to].color] = move.to;\n      /* if we castled, move the rook next to the king */\n\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        var castling_to = move.to - 1;\n        var castling_from = move.to + 1;\n        board[castling_to] = board[castling_from];\n        board[castling_from] = null;\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        var castling_to = move.to + 1;\n        var castling_from = move.to - 2;\n        board[castling_to] = board[castling_from];\n        board[castling_from] = null;\n      }\n      /* turn off castling */\n\n\n      castling[us] = '';\n    }\n    /* turn off castling if we move a rook */\n\n\n    if (castling[us]) {\n      for (var i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (move.from === ROOKS[us][i].square && castling[us] & ROOKS[us][i].flag) {\n          castling[us] ^= ROOKS[us][i].flag;\n          break;\n        }\n      }\n    }\n    /* turn off castling if we capture a rook */\n\n\n    if (castling[them]) {\n      for (var i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (move.to === ROOKS[them][i].square && castling[them] & ROOKS[them][i].flag) {\n          castling[them] ^= ROOKS[them][i].flag;\n          break;\n        }\n      }\n    }\n    /* if big pawn move, update the en passant square */\n\n\n    if (move.flags & BITS.BIG_PAWN) {\n      if (turn === 'b') {\n        ep_square = move.to - 16;\n      } else {\n        ep_square = move.to + 16;\n      }\n    } else {\n      ep_square = EMPTY;\n    }\n    /* reset the 50 move counter if a pawn is moved or a piece is captured */\n\n\n    if (move.piece === PAWN) {\n      half_moves = 0;\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      half_moves = 0;\n    } else {\n      half_moves++;\n    }\n\n    if (turn === BLACK) {\n      move_number++;\n    }\n\n    turn = swap_color(turn);\n  }\n\n  function undo_move() {\n    var old = history.pop();\n\n    if (old == null) {\n      return null;\n    }\n\n    var move = old.move;\n    kings = old.kings;\n    turn = old.turn;\n    castling = old.castling;\n    ep_square = old.ep_square;\n    half_moves = old.half_moves;\n    move_number = old.move_number;\n    var us = turn;\n    var them = swap_color(turn);\n    board[move.from] = board[move.to];\n    board[move.from].type = move.piece; // to undo any promotions\n\n    board[move.to] = null;\n\n    if (move.flags & BITS.CAPTURE) {\n      board[move.to] = {\n        type: move.captured,\n        color: them\n      };\n    } else if (move.flags & BITS.EP_CAPTURE) {\n      var index;\n\n      if (us === BLACK) {\n        index = move.to - 16;\n      } else {\n        index = move.to + 16;\n      }\n\n      board[index] = {\n        type: PAWN,\n        color: them\n      };\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      var castling_to, castling_from;\n\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castling_to = move.to + 1;\n        castling_from = move.to - 1;\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        castling_to = move.to - 2;\n        castling_from = move.to + 1;\n      }\n\n      board[castling_to] = board[castling_from];\n      board[castling_from] = null;\n    }\n\n    return move;\n  }\n  /* this function is used to uniquely identify ambiguous moves */\n\n\n  function get_disambiguator(move, moves) {\n    var from = move.from;\n    var to = move.to;\n    var piece = move.piece;\n    var ambiguities = 0;\n    var same_rank = 0;\n    var same_file = 0;\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      var ambig_from = moves[i].from;\n      var ambig_to = moves[i].to;\n      var ambig_piece = moves[i].piece;\n      /* if a move of the same piece type ends on the same to square, we'll\r\n       * need to add a disambiguator to the algebraic notation\r\n       */\n\n      if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\n        ambiguities++;\n\n        if (rank(from) === rank(ambig_from)) {\n          same_rank++;\n        }\n\n        if (file(from) === file(ambig_from)) {\n          same_file++;\n        }\n      }\n    }\n\n    if (ambiguities > 0) {\n      /* if there exists a similar moving piece on the same rank and file as\r\n       * the move in question, use the square as the disambiguator\r\n       */\n      if (same_rank > 0 && same_file > 0) {\n        return algebraic(from);\n      } else if (same_file > 0) {\n        /* if the moving piece rests on the same file, use the rank symbol as the\r\n         * disambiguator\r\n         */\n        return algebraic(from).charAt(1);\n      } else {\n        /* else use the file symbol */\n        return algebraic(from).charAt(0);\n      }\n    }\n\n    return '';\n  }\n\n  function infer_piece_type(san) {\n    var piece_type = san.charAt(0);\n\n    if (piece_type >= 'a' && piece_type <= 'h') {\n      var matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n\n      if (matches) {\n        return undefined;\n      }\n\n      return PAWN;\n    }\n\n    piece_type = piece_type.toLowerCase();\n\n    if (piece_type === 'o') {\n      return KING;\n    }\n\n    return piece_type;\n  }\n\n  function ascii() {\n    var s = '   +------------------------+\\n';\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* display the rank */\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |';\n      }\n      /* empty piece */\n\n\n      if (board[i] == null) {\n        s += ' . ';\n      } else {\n        var piece = board[i].type;\n        var color = board[i].color;\n        var symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n        s += ' ' + symbol + ' ';\n      }\n\n      if (i + 1 & 0x88) {\n        s += '|\\n';\n        i += 8;\n      }\n    }\n\n    s += '   +------------------------+\\n';\n    s += '     a  b  c  d  e  f  g  h\\n';\n    return s;\n  } // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n\n\n  function move_from_san(move, sloppy) {\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    var clean_move = stripped_san(move);\n    var overly_disambiguated = false;\n\n    if (sloppy) {\n      // The sloppy parser allows the user to parse non-standard chess\n      // notations. This parser is opt-in (by specifying the\n      // '{ sloppy: true }' setting) and is only run after the Standard\n      // Algebraic Notation (SAN) parser has failed.\n      //\n      // When running the sloppy parser, we'll run a regex to grab the piece,\n      // the to/from square, and an optional promotion piece. This regex will\n      // parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7, f7f8q,\n      // b1c3\n      // NOTE: Some positions and moves may be ambiguous when using the sloppy\n      // parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n      // the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated\n      // bishop move). In these cases, the sloppy parser will default to the\n      // most most basic interpretation - b1c3 parses to Nc3.\n      var matches = clean_move.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n\n      if (matches) {\n        var piece = matches[1];\n        var from = matches[2];\n        var to = matches[3];\n        var promotion = matches[4];\n\n        if (from.length == 1) {\n          overly_disambiguated = true;\n        }\n      } else {\n        // The [a-h]?[1-8]? portion of the regex below handles moves that may\n        // be overly disambiguated (e.g. Nge7 is unnecessary and non-standard\n        // when there is one legal knight move to e7). In this case, the value\n        // of 'from' variable will be a rank or file, not a square.\n        var matches = clean_move.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n\n        if (matches) {\n          var piece = matches[1];\n          var from = matches[2];\n          var to = matches[3];\n          var promotion = matches[4];\n\n          if (from.length == 1) {\n            var overly_disambiguated = true;\n          }\n        }\n      }\n    }\n\n    var piece_type = infer_piece_type(clean_move);\n    var moves = generate_moves({\n      legal: true,\n      piece: piece ? piece : piece_type\n    });\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      // try the strict parser first, then the sloppy parser if requested\n      // by the user\n      if (clean_move === stripped_san(move_to_san(moves[i], moves))) {\n        return moves[i];\n      } else {\n        if (sloppy && matches) {\n          // hand-compare move properties with the results from our sloppy\n          // regex\n          if ((!piece || piece.toLowerCase() == moves[i].piece) && SQUARES[from] == moves[i].from && SQUARES[to] == moves[i].to && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n            return moves[i];\n          } else if (overly_disambiguated) {\n            // SPECIAL CASE: we parsed a move string that may have an unneeded\n            // rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n            var square = algebraic(moves[i].from);\n\n            if ((!piece || piece.toLowerCase() == moves[i].piece) && SQUARES[to] == moves[i].to && (from == square[0] || from == square[1]) && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n              return moves[i];\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n  /*****************************************************************************\r\n   * UTILITY FUNCTIONS\r\n   ****************************************************************************/\n\n\n  function rank(i) {\n    return i >> 4;\n  }\n\n  function file(i) {\n    return i & 15;\n  }\n\n  function algebraic(i) {\n    var f = file(i),\n        r = rank(i);\n    return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n  }\n\n  function swap_color(c) {\n    return c === WHITE ? BLACK : WHITE;\n  }\n\n  function is_digit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n  }\n  /* pretty = external move object */\n\n\n  function make_pretty(ugly_move) {\n    var move = clone(ugly_move);\n    move.san = move_to_san(move, generate_moves({\n      legal: true\n    }));\n    move.to = algebraic(move.to);\n    move.from = algebraic(move.from);\n    var flags = '';\n\n    for (var flag in BITS) {\n      if (BITS[flag] & move.flags) {\n        flags += FLAGS[flag];\n      }\n    }\n\n    move.flags = flags;\n    return move;\n  }\n\n  function clone(obj) {\n    var dupe = obj instanceof Array ? [] : {};\n\n    for (var property in obj) {\n      if (typeof property === 'object') {\n        dupe[property] = clone(obj[property]);\n      } else {\n        dupe[property] = obj[property];\n      }\n    }\n\n    return dupe;\n  }\n\n  function trim(str) {\n    return str.replace(/^\\s+|\\s+$/g, '');\n  }\n  /*****************************************************************************\r\n   * DEBUGGING UTILITIES\r\n   ****************************************************************************/\n\n\n  function perft(depth) {\n    var moves = generate_moves({\n      legal: false\n    });\n    var nodes = 0;\n    var color = turn;\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i]);\n\n      if (!king_attacked(color)) {\n        if (depth - 1 > 0) {\n          var child_nodes = perft(depth - 1);\n          nodes += child_nodes;\n        } else {\n          nodes++;\n        }\n      }\n\n      undo_move();\n    }\n\n    return nodes;\n  }\n\n  return {\n    /***************************************************************************\r\n     * PUBLIC CONSTANTS (is there a better way to do this?)\r\n     **************************************************************************/\n    WHITE: WHITE,\n    BLACK: BLACK,\n    PAWN: PAWN,\n    KNIGHT: KNIGHT,\n    BISHOP: BISHOP,\n    ROOK: ROOK,\n    QUEEN: QUEEN,\n    KING: KING,\n    SQUARES: function () {\n      /* from the ECMA-262 spec (section 12.6.4):\r\n       * \"The mechanics of enumerating the properties ... is\r\n       * implementation dependent\"\r\n       * so: for (var sq in SQUARES) { keys.push(sq); } might not be\r\n       * ordered correctly\r\n       */\n      var keys = [];\n\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (i & 0x88) {\n          i += 7;\n          continue;\n        }\n\n        keys.push(algebraic(i));\n      }\n\n      return keys;\n    }(),\n    FLAGS: FLAGS,\n\n    /***************************************************************************\r\n     * PUBLIC API\r\n     **************************************************************************/\n    load: function (fen) {\n      return load(fen);\n    },\n    end_turn: function () {\n      end_turn();\n    },\n    reset: function () {\n      return reset();\n    },\n    moves: function (options) {\n      /* The internal representation of a chess move is in 0x88 format, and\r\n       * not meant to be human-readable.  The code below converts the 0x88\r\n       * square coordinates to algebraic coordinates.  It also prunes an\r\n       * unnecessary move keys resulting from a verbose call.\r\n       */\n      var ugly_moves = generate_moves(options);\n      var moves = [];\n\n      for (var i = 0, len = ugly_moves.length; i < len; i++) {\n        /* does the user want a full move object (most likely not), or just\r\n         * SAN\r\n         */\n        if (typeof options !== 'undefined' && 'verbose' in options && options.verbose) {\n          moves.push(make_pretty(ugly_moves[i]));\n        } else {\n          moves.push(move_to_san(ugly_moves[i], generate_moves({\n            legal: true\n          })));\n        }\n      }\n\n      return moves;\n    },\n    in_check: function () {\n      return in_check();\n    },\n    in_checkmate: function () {\n      return in_checkmate();\n    },\n    in_stalemate: function () {\n      return in_stalemate();\n    },\n    in_draw: function () {\n      return half_moves >= 100 || in_stalemate() || insufficient_material() || in_threefold_repetition();\n    },\n    insufficient_material: function () {\n      return insufficient_material();\n    },\n    in_threefold_repetition: function () {\n      return in_threefold_repetition();\n    },\n    game_over: function () {\n      return half_moves >= 100 || in_checkmate() || in_stalemate() || insufficient_material() || in_threefold_repetition();\n    },\n    validate_fen: function (fen) {\n      return validate_fen(fen);\n    },\n    fen: function () {\n      return generate_fen();\n    },\n    board: function () {\n      var output = [],\n          row = [];\n\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (board[i] == null) {\n          row.push(null);\n        } else {\n          row.push({\n            type: board[i].type,\n            color: board[i].color\n          });\n        }\n\n        if (i + 1 & 0x88) {\n          output.push(row);\n          row = [];\n          i += 8;\n        }\n      }\n\n      return output;\n    },\n    pgn: function (options) {\n      /* using the specification from http://www.chessclub.com/help/PGN-spec\r\n       * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\r\n       */\n      var newline = typeof options === 'object' && typeof options.newline_char === 'string' ? options.newline_char : '\\n';\n      var max_width = typeof options === 'object' && typeof options.max_width === 'number' ? options.max_width : 0;\n      var result = [];\n      var header_exists = false;\n      /* add the PGN header headerrmation */\n\n      for (var i in header) {\n        /* TODO: order of enumerated properties in header object is not\r\n         * guaranteed, see ECMA-262 spec (section 12.6.4)\r\n         */\n        result.push('[' + i + ' \"' + header[i] + '\"]' + newline);\n        header_exists = true;\n      }\n\n      if (header_exists && history.length) {\n        result.push(newline);\n      }\n\n      var append_comment = function (move_string) {\n        var comment = comments[generate_fen()];\n\n        if (typeof comment !== 'undefined') {\n          var delimiter = move_string.length > 0 ? ' ' : '';\n          move_string = `${move_string}${delimiter}{${comment}}`;\n        }\n\n        return move_string;\n      };\n      /* pop all of history onto reversed_history */\n\n\n      var reversed_history = [];\n\n      while (history.length > 0) {\n        reversed_history.push(undo_move());\n      }\n\n      var moves = [];\n      var move_string = '';\n      /* special case of a commented starting position with no moves */\n\n      if (reversed_history.length === 0) {\n        moves.push(append_comment(''));\n      }\n      /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n\n\n      while (reversed_history.length > 0) {\n        move_string = append_comment(move_string);\n        var move = reversed_history.pop();\n        /* if the position started with black to move, start PGN with 1. ... */\n\n        if (!history.length && move.color === 'b') {\n          move_string = move_number + '. ...';\n        } else if (move.color === 'w') {\n          /* store the previous generated move_string if we have one */\n          if (move_string.length) {\n            moves.push(move_string);\n          }\n\n          move_string = move_number + '.';\n        }\n\n        move_string = move_string + ' ' + move_to_san(move, generate_moves({\n          legal: true\n        }));\n        make_move(move);\n      }\n      /* are there any other leftover moves? */\n\n\n      if (move_string.length) {\n        moves.push(append_comment(move_string));\n      }\n      /* is there a result? */\n\n\n      if (typeof header.Result !== 'undefined') {\n        moves.push(header.Result);\n      }\n      /* history should be back to what it was before we started generating PGN,\r\n       * so join together moves\r\n       */\n\n\n      if (max_width === 0) {\n        return result.join('') + moves.join(' ');\n      }\n\n      var strip = function () {\n        if (result.length > 0 && result[result.length - 1] === ' ') {\n          result.pop();\n          return true;\n        }\n\n        return false;\n      };\n      /* NB: this does not preserve comment whitespace. */\n\n\n      var wrap_comment = function (width, move) {\n        for (var token of move.split(' ')) {\n          if (!token) {\n            continue;\n          }\n\n          if (width + token.length > max_width) {\n            while (strip()) {\n              width--;\n            }\n\n            result.push(newline);\n            width = 0;\n          }\n\n          result.push(token);\n          width += token.length;\n          result.push(' ');\n          width++;\n        }\n\n        if (strip()) {\n          width--;\n        }\n\n        return width;\n      };\n      /* wrap the PGN output at max_width */\n\n\n      var current_width = 0;\n\n      for (var i = 0; i < moves.length; i++) {\n        if (current_width + moves[i].length > max_width) {\n          if (moves[i].includes('{')) {\n            current_width = wrap_comment(current_width, moves[i]);\n            continue;\n          }\n        }\n        /* if the current move will push past max_width */\n\n\n        if (current_width + moves[i].length > max_width && i !== 0) {\n          /* don't end the line with whitespace */\n          if (result[result.length - 1] === ' ') {\n            result.pop();\n          }\n\n          result.push(newline);\n          current_width = 0;\n        } else if (i !== 0) {\n          result.push(' ');\n          current_width++;\n        }\n\n        result.push(moves[i]);\n        current_width += moves[i].length;\n      }\n\n      return result.join('');\n    },\n    load_pgn: function (pgn, options) {\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy = typeof options !== 'undefined' && 'sloppy' in options ? options.sloppy : false;\n\n      function mask(str) {\n        return str.replace(/\\\\/g, '\\\\');\n      }\n\n      function has_keys(object) {\n        for (var key in object) {\n          return true;\n        }\n\n        return false;\n      }\n\n      function parse_pgn_header(header, options) {\n        var newline_char = typeof options === 'object' && typeof options.newline_char === 'string' ? options.newline_char : '\\r?\\n';\n        var header_obj = {};\n        var headers = header.split(new RegExp(mask(newline_char)));\n        var key = '';\n        var value = '';\n\n        for (var i = 0; i < headers.length; i++) {\n          key = headers[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1');\n          value = headers[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\ *\\]$/, '$1');\n\n          if (trim(key).length > 0) {\n            header_obj[key] = value;\n          }\n        }\n\n        return header_obj;\n      }\n\n      var newline_char = typeof options === 'object' && typeof options.newline_char === 'string' ? options.newline_char : '\\r?\\n'; // RegExp to split header. Takes advantage of the fact that header and movetext\n      // will always have a blank line between them (ie, two newline_char's).\n      // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\r?\\n){2}/\n\n      var header_regex = new RegExp('^(\\\\[((?:' + mask(newline_char) + ')|.)*\\\\])' + '(?:' + mask(newline_char) + '){2}'); // If no header given, begin with moves.\n\n      var header_string = header_regex.test(pgn) ? header_regex.exec(pgn)[1] : ''; // Put the board in the starting position\n\n      reset();\n      /* parse PGN header */\n\n      var headers = parse_pgn_header(header_string, options);\n\n      for (var key in headers) {\n        set_header([key, headers[key]]);\n      }\n      /* load the starting position indicated by [Setup '1'] and\r\n       * [FEN position] */\n\n\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers && load(headers['FEN'], true))) {\n          // second argument to load: don't clear the headers\n          return false;\n        }\n      }\n      /* NB: the regexes below that delete move numbers, recursive\r\n       * annotations, and numeric annotation glyphs may also match\r\n       * text in comments. To prevent this, we transform comments\r\n       * by hex-encoding them in place and decoding them again after\r\n       * the other tokens have been deleted.\r\n       *\r\n       * While the spec states that PGN files should be ASCII encoded,\r\n       * we use {en,de}codeURIComponent here to support arbitrary UTF8\r\n       * as a convenience for modern users */\n\n\n      var to_hex = function (string) {\n        return Array.from(string).map(function (c) {\n          /* encodeURI doesn't transform most ASCII characters,\r\n           * so we handle these ourselves */\n          return c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/\\%/g, '').toLowerCase();\n        }).join('');\n      };\n\n      var from_hex = function (string) {\n        return string.length == 0 ? '' : decodeURIComponent('%' + string.match(/.{1,2}/g).join('%'));\n      };\n\n      var encode_comment = function (string) {\n        string = string.replace(new RegExp(mask(newline_char), 'g'), ' ');\n        return `{${to_hex(string.slice(1, string.length - 1))}}`;\n      };\n\n      var decode_comment = function (string) {\n        if (string.startsWith('{') && string.endsWith('}')) {\n          return from_hex(string.slice(1, string.length - 1));\n        }\n      };\n      /* delete header to get the moves */\n\n\n      var ms = pgn.replace(header_string, '').replace(\n      /* encode comments so they don't get deleted below */\n      new RegExp(`(\\{[^}]*\\})+?|;([^${mask(newline_char)}]*)`, 'g'), function (match, bracket, semicolon) {\n        return bracket !== undefined ? encode_comment(bracket) : ' ' + encode_comment(`{${semicolon.slice(1)}}`);\n      }).replace(new RegExp(mask(newline_char), 'g'), ' ');\n      /* delete recursive annotation variations */\n\n      var rav_regex = /(\\([^\\(\\)]+\\))+?/g;\n\n      while (rav_regex.test(ms)) {\n        ms = ms.replace(rav_regex, '');\n      }\n      /* delete move numbers */\n\n\n      ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n      /* delete ... indicating black to move */\n\n      ms = ms.replace(/\\.\\.\\./g, '');\n      /* delete numeric annotation glyphs */\n\n      ms = ms.replace(/\\$\\d+/g, '');\n      /* trim and get array of moves */\n\n      var moves = trim(ms).split(new RegExp(/\\s+/));\n      /* delete empty entries */\n\n      moves = moves.join(',').replace(/,,+/g, ',').split(',');\n      var move = '';\n      var result = '';\n\n      for (var half_move = 0; half_move < moves.length; half_move++) {\n        var comment = decode_comment(moves[half_move]);\n\n        if (comment !== undefined) {\n          comments[generate_fen()] = comment;\n          continue;\n        }\n\n        move = move_from_san(moves[half_move], sloppy);\n        /* invalid move */\n\n        if (move == null) {\n          /* was the move an end of game marker */\n          if (TERMINATION_MARKERS.indexOf(moves[half_move]) > -1) {\n            result = moves[half_move];\n          } else {\n            return false;\n          }\n        } else {\n          /* reset the end of game marker if making a valid move */\n          result = '';\n          make_move(move);\n        }\n      }\n      /* Per section 8.2.6 of the PGN spec, the Result tag pair must match\r\n       * match the termination marker. Only do this when headers are present,\r\n       * but the result tag is missing\r\n       */\n\n\n      if (result && Object.keys(header).length && !header['Result']) {\n        set_header(['Result', result]);\n      }\n\n      return true;\n    },\n    header: function () {\n      return set_header(arguments);\n    },\n    ascii: function () {\n      return ascii();\n    },\n    turn: function () {\n      return turn;\n    },\n    move: function (move, options) {\n      /* The move function can be called with in the following parameters:\r\n       *\r\n       * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\r\n       *\r\n       * .move({ from: 'h7', <- where the 'move' is a move object (additional\r\n       *         to :'h8',      fields are ignored)\r\n       *         promotion: 'q',\r\n       *      })\r\n       */\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy = typeof options !== 'undefined' && 'sloppy' in options ? options.sloppy : false;\n      var move_obj = null;\n\n      if (typeof move === 'string') {\n        move_obj = move_from_san(move, sloppy);\n      } else if (typeof move === 'object') {\n        var moves = generate_moves();\n        /* convert the pretty move object to an ugly move object */\n\n        for (var i = 0, len = moves.length; i < len; i++) {\n          if (move.from === algebraic(moves[i].from) && move.to === algebraic(moves[i].to) && (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n            move_obj = moves[i];\n            break;\n          }\n        }\n      }\n      /* failed to find move */\n\n\n      if (!move_obj) {\n        return null;\n      }\n      /* need to make a copy of move because we can't generate SAN after the\r\n       * move is made\r\n       */\n\n\n      var pretty_move = make_pretty(move_obj);\n      make_move(move_obj);\n      return pretty_move;\n    },\n    undo: function () {\n      var move = undo_move();\n      return move ? make_pretty(move) : null;\n    },\n    clear: function () {\n      return clear();\n    },\n    put: function (piece, square) {\n      return put(piece, square);\n    },\n    get: function (square) {\n      return get(square);\n    },\n    remove: function (square) {\n      return remove(square);\n    },\n    perft: function (depth) {\n      return perft(depth);\n    },\n    square_color: function (square) {\n      if (square in SQUARES) {\n        var sq_0x88 = SQUARES[square];\n        return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? 'light' : 'dark';\n      }\n\n      return null;\n    },\n    history: function (options) {\n      var reversed_history = [];\n      var move_history = [];\n      var verbose = typeof options !== 'undefined' && 'verbose' in options && options.verbose;\n\n      while (history.length > 0) {\n        reversed_history.push(undo_move());\n      }\n\n      while (reversed_history.length > 0) {\n        var move = reversed_history.pop();\n\n        if (verbose) {\n          move_history.push(make_pretty(move));\n        } else {\n          move_history.push(move_to_san(move, generate_moves({\n            legal: true\n          })));\n        }\n\n        make_move(move);\n      }\n\n      return move_history;\n    },\n    get_comment: function () {\n      return comments[generate_fen()];\n    },\n    set_comment: function (comment) {\n      comments[generate_fen()] = comment.replace('{', '[').replace('}', ']');\n    },\n    delete_comment: function () {\n      var comment = comments[generate_fen()];\n      delete comments[generate_fen()];\n      return comment;\n    },\n    get_comments: function () {\n      prune_comments();\n      return Object.keys(comments).map(function (fen) {\n        return {\n          fen: fen,\n          comment: comments[fen]\n        };\n      });\n    },\n    delete_comments: function () {\n      prune_comments();\n      return Object.keys(comments).map(function (fen) {\n        var comment = comments[fen];\n        delete comments[fen];\n        return {\n          fen: fen,\n          comment: comment\n        };\n      });\n    }\n  };\n}\n_c = Chess;\n\nvar _c;\n\n$RefreshReg$(_c, \"Chess\");","map":{"version":3,"names":["Chess","fen","BLACK","WHITE","EMPTY","PAWN","KNIGHT","BISHOP","ROOK","QUEEN","KING","SYMBOLS","DEFAULT_POSITION","TERMINATION_MARKERS","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","k","ATTACKS","RAYS","SHIFTS","p","FLAGS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","BITS","RANK_1","RANK_2","RANK_3","RANK_4","RANK_5","RANK_6","RANK_7","RANK_8","SQUARES","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","ROOKS","square","flag","board","Array","kings","turn","castling","ep_square","half_moves","move_number","history","header","comments","load","clear","keep_headers","update_setup","generate_fen","prune_comments","reversed_history","current_comments","copy_comment","length","push","undo_move","make_move","pop","reset","tokens","split","position","validate_fen","valid","i","piece","charAt","is_digit","parseInt","color","put","type","toLowerCase","algebraic","indexOf","errors","error_number","error","isNaN","test","rows","sum_fields","previous_was_number","empty","toUpperCase","cflags","epflags","join","set_header","args","get","sq","remove","build_move","from","to","flags","promotion","move","captured","generate_moves","options","add_move","moves","rank","pieces","len","us","them","swap_color","second_rank","first_sq","last_sq","single_square","legal","piece_type","j","offset","castling_from","castling_to","attacked","legal_moves","king_attacked","end_turn","move_to_san","output","disambiguator","get_disambiguator","in_check","in_checkmate","stripped_san","replace","difference","index","blocked","in_stalemate","insufficient_material","bishops","num_pieces","sq_color","sum","in_threefold_repetition","positions","repetition","slice","old","ambiguities","same_rank","same_file","ambig_from","ambig_to","ambig_piece","file","infer_piece_type","san","matches","match","undefined","ascii","s","symbol","move_from_san","sloppy","clean_move","overly_disambiguated","f","substring","c","make_pretty","ugly_move","clone","obj","dupe","property","trim","str","perft","depth","nodes","child_nodes","keys","ugly_moves","verbose","in_draw","game_over","row","pgn","newline","newline_char","max_width","result","header_exists","append_comment","move_string","comment","delimiter","Result","strip","wrap_comment","width","token","current_width","includes","load_pgn","mask","has_keys","object","key","parse_pgn_header","header_obj","headers","RegExp","value","header_regex","header_string","exec","to_hex","string","map","charCodeAt","toString","encodeURIComponent","from_hex","decodeURIComponent","encode_comment","decode_comment","startsWith","endsWith","ms","bracket","semicolon","rav_regex","half_move","Object","arguments","move_obj","pretty_move","undo","square_color","sq_0x88","move_history","get_comment","set_comment","delete_comment","get_comments","delete_comments"],"sources":["/home/kurone/unist/se/UNISTAGRAM/src/main/frontend/src/ultils/chess.js"],"sourcesContent":["/*\r\n * Copyright (c) 2021, Jeff Hlywa (jhlywa@gmail.com)\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n *----------------------------------------------------------------------------*/\r\n\r\nexport default function Chess(fen) {\r\n    var BLACK = 'b'\r\n    var WHITE = 'w'\r\n  \r\n    var EMPTY = -1\r\n  \r\n    var PAWN = 'p'\r\n    var KNIGHT = 'n'\r\n    var BISHOP = 'b'\r\n    var ROOK = 'r'\r\n    var QUEEN = 'q'\r\n    var KING = 'k'\r\n  \r\n    var SYMBOLS = 'pnbrqkPNBRQK'\r\n  \r\n    var DEFAULT_POSITION =\r\n      'ppppkppp/pppppppp/8/8/8/8/PPPPPPPP/PPPPKPPP w - - 0 1'\r\n  \r\n    var TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*']\r\n  \r\n    var PAWN_OFFSETS = {\r\n      b: [16, 32, 17, 15],\r\n      w: [-16, -32, -17, -15],\r\n    }\r\n  \r\n    var PIECE_OFFSETS = {\r\n      n: [-18, -33, -31, -14, 18, 33, 31, 14],\r\n      b: [-17, -15, 17, 15],\r\n      r: [-16, 1, 16, -1],\r\n      q: [-17, -16, -15, 1, 17, 16, 15, -1],\r\n      k: [-17, -16, -15, 1, 17, 16, 15, -1],\r\n    }\r\n  \r\n    // prettier-ignore\r\n    var ATTACKS = [\r\n      20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\r\n       0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\r\n       0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\r\n       0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\r\n       0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\r\n       0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\r\n       0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\r\n      24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\r\n       0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\r\n       0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\r\n       0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\r\n       0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\r\n       0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\r\n       0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\r\n      20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\r\n    ];\r\n  \r\n    // prettier-ignore\r\n    var RAYS = [\r\n       17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\r\n        0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\r\n        0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\r\n        0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\r\n        0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\r\n        0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\r\n        0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\r\n        1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\r\n        0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\r\n        0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\r\n        0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\r\n        0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\r\n        0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\r\n        0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\r\n      -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\r\n    ];\r\n  \r\n    var SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 }\r\n  \r\n    var FLAGS = {\r\n      NORMAL: 'n',\r\n      CAPTURE: 'c',\r\n      BIG_PAWN: 'b',\r\n      EP_CAPTURE: 'e',\r\n      PROMOTION: 'p',\r\n      KSIDE_CASTLE: 'k',\r\n      QSIDE_CASTLE: 'q',\r\n    }\r\n  \r\n    var BITS = {\r\n      NORMAL: 1,\r\n      CAPTURE: 2,\r\n      BIG_PAWN: 4,\r\n      EP_CAPTURE: 8,\r\n      PROMOTION: 16,\r\n      KSIDE_CASTLE: 32,\r\n      QSIDE_CASTLE: 64,\r\n    }\r\n  \r\n    var RANK_1 = 7\r\n    var RANK_2 = 6\r\n    var RANK_3 = 5\r\n    var RANK_4 = 4\r\n    var RANK_5 = 3\r\n    var RANK_6 = 2\r\n    var RANK_7 = 1\r\n    var RANK_8 = 0\r\n  \r\n    // prettier-ignore\r\n    var SQUARES = {\r\n      a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\r\n      a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\r\n      a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\r\n      a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\r\n      a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\r\n      a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\r\n      a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\r\n      a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\r\n    };\r\n  \r\n    var ROOKS = {\r\n      w: [\r\n        { square: SQUARES.a1, flag: BITS.QSIDE_CASTLE },\r\n        { square: SQUARES.h1, flag: BITS.KSIDE_CASTLE },\r\n      ],\r\n      b: [\r\n        { square: SQUARES.a8, flag: BITS.QSIDE_CASTLE },\r\n        { square: SQUARES.h8, flag: BITS.KSIDE_CASTLE },\r\n      ],\r\n    }\r\n  \r\n    var board = new Array(128)\r\n    var kings = { w: EMPTY, b: EMPTY }\r\n    var turn = WHITE\r\n    var castling = { w: 0, b: 0 }\r\n    var ep_square = EMPTY\r\n    var half_moves = 0\r\n    var move_number = 1\r\n    var history = []\r\n    var header = {}\r\n    var comments = {}\r\n  \r\n    /* if the user passes in a fen string, load it, else default to\r\n     * starting position\r\n     */\r\n    if (typeof fen === 'undefined') {\r\n      load(DEFAULT_POSITION)\r\n    } else {\r\n      load(fen)\r\n    }\r\n  \r\n    function clear(keep_headers) {\r\n      if (typeof keep_headers === 'undefined') {\r\n        keep_headers = false\r\n      }\r\n  \r\n      board = new Array(128)\r\n      kings = { w: EMPTY, b: EMPTY }\r\n      turn = WHITE\r\n      castling = { w: 0, b: 0 }\r\n      ep_square = EMPTY\r\n      half_moves = 0\r\n      move_number = 1\r\n      history = []\r\n      if (!keep_headers) header = {}\r\n      comments = {}\r\n      update_setup(generate_fen())\r\n    }\r\n  \r\n    function prune_comments() {\r\n      var reversed_history = []\r\n      var current_comments = {}\r\n      var copy_comment = function (fen) {\r\n        if (fen in comments) {\r\n          current_comments[fen] = comments[fen]\r\n        }\r\n      }\r\n      while (history.length > 0) {\r\n        reversed_history.push(undo_move())\r\n      }\r\n      copy_comment(generate_fen())\r\n      while (reversed_history.length > 0) {\r\n        make_move(reversed_history.pop())\r\n        copy_comment(generate_fen())\r\n      }\r\n      comments = current_comments\r\n    }\r\n  \r\n    function reset() {\r\n      load(DEFAULT_POSITION)\r\n    }\r\n  \r\n    function load(fen, keep_headers) {\r\n      if (typeof keep_headers === 'undefined') {\r\n        keep_headers = false\r\n      }\r\n  \r\n      var tokens = fen.split(/\\s+/)\r\n      var position = tokens[0]\r\n      var square = 0\r\n  \r\n      if (!validate_fen(fen).valid) {\r\n        return false\r\n      }\r\n  \r\n      clear(keep_headers)\r\n  \r\n      for (var i = 0; i < position.length; i++) {\r\n        var piece = position.charAt(i)\r\n  \r\n        if (piece === '/') {\r\n          square += 8\r\n        } else if (is_digit(piece)) {\r\n          square += parseInt(piece, 10)\r\n        } else {\r\n          var color = piece < 'a' ? WHITE : BLACK\r\n          put({ type: piece.toLowerCase(), color: color }, algebraic(square))\r\n          square++\r\n        }\r\n      }\r\n  \r\n      turn = tokens[1]\r\n  \r\n      if (tokens[2].indexOf('K') > -1) {\r\n        castling.w |= BITS.KSIDE_CASTLE\r\n      }\r\n      if (tokens[2].indexOf('Q') > -1) {\r\n        castling.w |= BITS.QSIDE_CASTLE\r\n      }\r\n      if (tokens[2].indexOf('k') > -1) {\r\n        castling.b |= BITS.KSIDE_CASTLE\r\n      }\r\n      if (tokens[2].indexOf('q') > -1) {\r\n        castling.b |= BITS.QSIDE_CASTLE\r\n      }\r\n  \r\n      ep_square = tokens[3] === '-' ? EMPTY : SQUARES[tokens[3]]\r\n      half_moves = parseInt(tokens[4], 10)\r\n      move_number = parseInt(tokens[5], 10)\r\n  \r\n      update_setup(generate_fen())\r\n  \r\n      return true\r\n    }\r\n  \r\n    /* TODO: this function is pretty much crap - it validates structure but\r\n     * completely ignores content (e.g. doesn't verify that each side has a king)\r\n     * ... we should rewrite this, and ditch the silly error_number field while\r\n     * we're at it\r\n     */\r\n    function validate_fen(fen) {\r\n      var errors = {\r\n        0: 'No errors.',\r\n        1: 'FEN string must contain six space-delimited fields.',\r\n        2: '6th field (move number) must be a positive integer.',\r\n        3: '5th field (half move counter) must be a non-negative integer.',\r\n        4: '4th field (en-passant square) is invalid.',\r\n        5: '3rd field (castling availability) is invalid.',\r\n        6: '2nd field (side to move) is invalid.',\r\n        7: \"1st field (piece positions) does not contain 8 '/'-delimited rows.\",\r\n        8: '1st field (piece positions) is invalid [consecutive numbers].',\r\n        9: '1st field (piece positions) is invalid [invalid piece].',\r\n        10: '1st field (piece positions) is invalid [row too large].',\r\n        11: 'Illegal en-passant square',\r\n      }\r\n  \r\n      /* 1st criterion: 6 space-seperated fields? */\r\n      var tokens = fen.split(/\\s+/)\r\n      if (tokens.length !== 6) {\r\n        return { valid: false, error_number: 1, error: errors[1] }\r\n      }\r\n  \r\n      /* 2nd criterion: move number field is a integer value > 0? */\r\n      if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) {\r\n        return { valid: false, error_number: 2, error: errors[2] }\r\n      }\r\n  \r\n      /* 3rd criterion: half move counter is an integer >= 0? */\r\n      if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) {\r\n        return { valid: false, error_number: 3, error: errors[3] }\r\n      }\r\n  \r\n      /* 4th criterion: 4th field is a valid e.p.-string? */\r\n      if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\r\n        return { valid: false, error_number: 4, error: errors[4] }\r\n      }\r\n  \r\n      /* 5th criterion: 3th field is a valid castle-string? */\r\n      if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\r\n        return { valid: false, error_number: 5, error: errors[5] }\r\n      }\r\n  \r\n      /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\r\n      if (!/^(w|b)$/.test(tokens[1])) {\r\n        return { valid: false, error_number: 6, error: errors[6] }\r\n      }\r\n  \r\n      /* 7th criterion: 1st field contains 8 rows? */\r\n      var rows = tokens[0].split('/')\r\n      if (rows.length !== 8) {\r\n        return { valid: false, error_number: 7, error: errors[7] }\r\n      }\r\n  \r\n      /* 8th criterion: every row is valid? */\r\n      for (var i = 0; i < rows.length; i++) {\r\n        /* check for right sum of fields AND not two numbers in succession */\r\n        var sum_fields = 0\r\n        var previous_was_number = false\r\n  \r\n        for (var k = 0; k < rows[i].length; k++) {\r\n          if (!isNaN(rows[i][k])) {\r\n            if (previous_was_number) {\r\n              return { valid: false, error_number: 8, error: errors[8] }\r\n            }\r\n            sum_fields += parseInt(rows[i][k], 10)\r\n            previous_was_number = true\r\n          } else {\r\n            if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\r\n              return { valid: false, error_number: 9, error: errors[9] }\r\n            }\r\n            sum_fields += 1\r\n            previous_was_number = false\r\n          }\r\n        }\r\n        if (sum_fields !== 8) {\r\n          return { valid: false, error_number: 10, error: errors[10] }\r\n        }\r\n      }\r\n  \r\n      if (\r\n        (tokens[3][1] == '3' && tokens[1] == 'w') ||\r\n        (tokens[3][1] == '6' && tokens[1] == 'b')\r\n      ) {\r\n        return { valid: false, error_number: 11, error: errors[11] }\r\n      }\r\n  \r\n      /* everything's okay! */\r\n      return { valid: true, error_number: 0, error: errors[0] }\r\n    }\r\n  \r\n    function generate_fen() {\r\n      var empty = 0\r\n      var fen = ''\r\n  \r\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\r\n        if (board[i] == null) {\r\n          empty++\r\n        } else {\r\n          if (empty > 0) {\r\n            fen += empty\r\n            empty = 0\r\n          }\r\n          var color = board[i].color\r\n          var piece = board[i].type\r\n  \r\n          fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\r\n        }\r\n  \r\n        if ((i + 1) & 0x88) {\r\n          if (empty > 0) {\r\n            fen += empty\r\n          }\r\n  \r\n          if (i !== SQUARES.h1) {\r\n            fen += '/'\r\n          }\r\n  \r\n          empty = 0\r\n          i += 8\r\n        }\r\n      }\r\n  \r\n      var cflags = ''\r\n      if (castling[WHITE] & BITS.KSIDE_CASTLE) {\r\n        cflags += 'K'\r\n      }\r\n      if (castling[WHITE] & BITS.QSIDE_CASTLE) {\r\n        cflags += 'Q'\r\n      }\r\n      if (castling[BLACK] & BITS.KSIDE_CASTLE) {\r\n        cflags += 'k'\r\n      }\r\n      if (castling[BLACK] & BITS.QSIDE_CASTLE) {\r\n        cflags += 'q'\r\n      }\r\n  \r\n      /* do we have an empty castling flag? */\r\n      cflags = cflags || '-'\r\n      var epflags = ep_square === EMPTY ? '-' : algebraic(ep_square)\r\n  \r\n      return [fen, turn, cflags, epflags, half_moves, move_number].join(' ')\r\n    }\r\n  \r\n    function set_header(args) {\r\n      for (var i = 0; i < args.length; i += 2) {\r\n        if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\r\n          header[args[i]] = args[i + 1]\r\n        }\r\n      }\r\n      return header\r\n    }\r\n  \r\n    /* called when the initial board setup is changed with put() or remove().\r\n     * modifies the SetUp and FEN properties of the header object.  if the FEN is\r\n     * equal to the default position, the SetUp and FEN are deleted\r\n     * the setup is only updated if history.length is zero, ie moves haven't been\r\n     * made.\r\n     */\r\n    function update_setup(fen) {\r\n      if (history.length > 0) return\r\n  \r\n      if (fen !== DEFAULT_POSITION) {\r\n        header['SetUp'] = '1'\r\n        header['FEN'] = fen\r\n      } else {\r\n        delete header['SetUp']\r\n        delete header['FEN']\r\n      }\r\n    }\r\n  \r\n    function get(square) {\r\n      var piece = board[SQUARES[square]]\r\n      return piece ? { type: piece.type, color: piece.color } : null\r\n    }\r\n  \r\n    function put(piece, square) {\r\n      /* check for valid piece object */\r\n      if (!('type' in piece && 'color' in piece)) {\r\n        return false\r\n      }\r\n  \r\n      /* check for piece */\r\n      if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\r\n        return false\r\n      }\r\n  \r\n      /* check for valid square */\r\n      if (!(square in SQUARES)) {\r\n        return false\r\n      }\r\n  \r\n      var sq = SQUARES[square]\r\n  \r\n      /* don't let the user place more than one king */\r\n      if (\r\n        piece.type == KING &&\r\n        !(kings[piece.color] == EMPTY || kings[piece.color] == sq)\r\n      ) {\r\n        return false\r\n      }\r\n  \r\n      board[sq] = { type: piece.type, color: piece.color }\r\n      if (piece.type === KING) {\r\n        kings[piece.color] = sq\r\n      }\r\n  \r\n      update_setup(generate_fen())\r\n  \r\n      return true\r\n    }\r\n  \r\n    function remove(square) {\r\n      var piece = get(square)\r\n      board[SQUARES[square]] = null\r\n      if (piece && piece.type === KING) {\r\n        kings[piece.color] = EMPTY\r\n      }\r\n  \r\n      update_setup(generate_fen())\r\n  \r\n      return piece\r\n    }\r\n  \r\n    function build_move(board, from, to, flags, promotion) {\r\n      var move = {\r\n        color: turn,\r\n        from: from,\r\n        to: to,\r\n        flags: flags,\r\n        piece: board[from].type,\r\n      }\r\n  \r\n      if (promotion) {\r\n        move.flags |= BITS.PROMOTION\r\n        move.promotion = promotion\r\n      }\r\n  \r\n      if (board[to]) {\r\n        move.captured = board[to].type\r\n      } else if (flags & BITS.EP_CAPTURE) {\r\n        move.captured = PAWN\r\n      }\r\n      return move\r\n    }\r\n  \r\n    function generate_moves(options) {\r\n      function add_move(board, moves, from, to, flags) {\r\n        /* if pawn promotion */\r\n        if (\r\n          board[from].type === PAWN &&\r\n          (rank(to) === RANK_8 || rank(to) === RANK_1)\r\n        ) {\r\n          var pieces = [QUEEN, ROOK, BISHOP, KNIGHT]\r\n          for (var i = 0, len = pieces.length; i < len; i++) {\r\n            moves.push(build_move(board, from, to, flags, pieces[i]))\r\n          }\r\n        } else {\r\n          moves.push(build_move(board, from, to, flags))\r\n        }\r\n      }\r\n  \r\n      var moves = []\r\n      var us = turn\r\n      var them = swap_color(us)\r\n      var second_rank = { b: RANK_7, w: RANK_2 }\r\n  \r\n      var first_sq = SQUARES.a8\r\n      var last_sq = SQUARES.h1\r\n      var single_square = false\r\n  \r\n      /* do we want legal moves? */\r\n      var legal =\r\n        typeof options !== 'undefined' && 'legal' in options\r\n          ? options.legal\r\n          : true\r\n  \r\n      var piece_type =\r\n        typeof options !== 'undefined' &&\r\n        'piece' in options &&\r\n        typeof options.piece === 'string'\r\n          ? options.piece.toLowerCase()\r\n          : true\r\n  \r\n      /* are we generating moves for a single square? */\r\n      if (typeof options !== 'undefined' && 'square' in options) {\r\n        if (options.square in SQUARES) {\r\n          first_sq = last_sq = SQUARES[options.square]\r\n          single_square = true\r\n        } else {\r\n          /* invalid square */\r\n          return []\r\n        }\r\n      }\r\n  \r\n      for (var i = first_sq; i <= last_sq; i++) {\r\n        /* did we run off the end of the board */\r\n        if (i & 0x88) {\r\n          i += 7\r\n          continue\r\n        }\r\n  \r\n        var piece = board[i]\r\n        if (piece == null || piece.color !== us) {\r\n          continue\r\n        }\r\n  \r\n        if (piece.type === PAWN && (piece_type === true || piece_type === PAWN)) {\r\n          /* single square, non-capturing */\r\n          var square = i + PAWN_OFFSETS[us][0]\r\n          if (board[square] == null) {\r\n            add_move(board, moves, i, square, BITS.NORMAL)\r\n  \r\n            /* double square */\r\n            var square = i + PAWN_OFFSETS[us][1]\r\n            if (second_rank[us] === rank(i) && board[square] == null) {\r\n              add_move(board, moves, i, square, BITS.BIG_PAWN)\r\n            }\r\n          }\r\n  \r\n          /* pawn captures */\r\n          for (j = 2; j < 4; j++) {\r\n            var square = i + PAWN_OFFSETS[us][j]\r\n            if (square & 0x88) continue\r\n  \r\n            if (board[square] != null && board[square].color === them) {\r\n              add_move(board, moves, i, square, BITS.CAPTURE)\r\n            } else if (square === ep_square) {\r\n              add_move(board, moves, i, ep_square, BITS.EP_CAPTURE)\r\n            }\r\n          }\r\n        } else if (piece_type === true || piece_type === piece.type) {\r\n          for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {\r\n            var offset = PIECE_OFFSETS[piece.type][j]\r\n            var square = i\r\n  \r\n            while (true) {\r\n              square += offset\r\n              if (square & 0x88) break\r\n  \r\n              if (board[square] == null) {\r\n                add_move(board, moves, i, square, BITS.NORMAL)\r\n              } else {\r\n                if (board[square].color === us) break\r\n                add_move(board, moves, i, square, BITS.CAPTURE)\r\n                break\r\n              }\r\n  \r\n              /* break, if knight or king */\r\n              if (piece.type === 'n' || piece.type === 'k') break\r\n            }\r\n          }\r\n        }\r\n      }\r\n  \r\n      /* check for castling if: a) we're generating all moves, or b) we're doing\r\n       * single square move generation on the king's square\r\n       */\r\n      if (piece_type === true || piece_type === KING) {\r\n        if (!single_square || last_sq === kings[us]) {\r\n          /* king-side castling */\r\n          if (castling[us] & BITS.KSIDE_CASTLE) {\r\n            var castling_from = kings[us]\r\n            var castling_to = castling_from + 2\r\n  \r\n            if (\r\n              board[castling_from + 1] == null &&\r\n              board[castling_to] == null &&\r\n              !attacked(them, kings[us]) &&\r\n              !attacked(them, castling_from + 1) &&\r\n              !attacked(them, castling_to)\r\n            ) {\r\n              add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE)\r\n            }\r\n          }\r\n  \r\n          /* queen-side castling */\r\n          if (castling[us] & BITS.QSIDE_CASTLE) {\r\n            var castling_from = kings[us]\r\n            var castling_to = castling_from - 2\r\n  \r\n            if (\r\n              board[castling_from - 1] == null &&\r\n              board[castling_from - 2] == null &&\r\n              board[castling_from - 3] == null &&\r\n              !attacked(them, kings[us]) &&\r\n              !attacked(them, castling_from - 1) &&\r\n              !attacked(them, castling_to)\r\n            ) {\r\n              add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE)\r\n            }\r\n          }\r\n        }\r\n      }\r\n  \r\n      /* return all pseudo-legal moves (this includes moves that allow the king\r\n       * to be captured)\r\n       */\r\n      if (!legal) {\r\n        return moves\r\n      }\r\n  \r\n      /* filter out illegal moves */\r\n      var legal_moves = []\r\n      for (var i = 0, len = moves.length; i < len; i++) {\r\n        make_move(moves[i])\r\n        if (!king_attacked(us)) {\r\n          legal_moves.push(moves[i])\r\n        }\r\n        undo_move()\r\n      }\r\n  \r\n      return legal_moves\r\n    }\r\n  \r\n    function end_turn(){\r\n      turn = swap_color(turn);\r\n    }\r\n  \r\n    /* convert a move from 0x88 coordinates to Standard Algebraic Notation\r\n     * (SAN)\r\n     *\r\n     * @param {boolean} sloppy Use the sloppy SAN generator to work around over\r\n     * disambiguation bugs in Fritz and Chessbase.  See below:\r\n     *\r\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\r\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\r\n     * 4. ... Ne7 is technically the valid SAN\r\n     */\r\n    function move_to_san(move, moves) {\r\n      var output = ''\r\n  \r\n      if (move.flags & BITS.KSIDE_CASTLE) {\r\n        output = 'O-O'\r\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\r\n        output = 'O-O-O'\r\n      } else {\r\n        if (move.piece !== PAWN) {\r\n          var disambiguator = get_disambiguator(move, moves)\r\n          output += move.piece.toUpperCase() + disambiguator\r\n        }\r\n  \r\n        if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\r\n          if (move.piece === PAWN) {\r\n            output += algebraic(move.from)[0]\r\n          }\r\n          output += 'x'\r\n        }\r\n  \r\n        output += algebraic(move.to)\r\n  \r\n        if (move.flags & BITS.PROMOTION) {\r\n          output += '=' + move.promotion.toUpperCase()\r\n        }\r\n      }\r\n  \r\n      make_move(move)\r\n      if (in_check()) {\r\n        if (in_checkmate()) {\r\n          output += '#'\r\n        } else {\r\n          output += '+'\r\n        }\r\n      }\r\n      undo_move()\r\n  \r\n      return output\r\n    }\r\n    // parses all of the decorators out of a SAN string\r\n    function stripped_san(move) {\r\n      return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\r\n    }\r\n  \r\n    function attacked(color, square) {\r\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\r\n        /* did we run off the end of the board */\r\n        if (i & 0x88) {\r\n          i += 7\r\n          continue\r\n        }\r\n  \r\n        /* if empty square or wrong color */\r\n        if (board[i] == null || board[i].color !== color) continue\r\n  \r\n        var piece = board[i]\r\n        var difference = i - square\r\n        var index = difference + 119\r\n  \r\n        if (ATTACKS[index] & (1 << SHIFTS[piece.type])) {\r\n          if (piece.type === PAWN) {\r\n            if (difference > 0) {\r\n              if (piece.color === WHITE) return true\r\n            } else {\r\n              if (piece.color === BLACK) return true\r\n            }\r\n            continue\r\n          }\r\n  \r\n          /* if the piece is a knight or a king */\r\n          if (piece.type === 'n' || piece.type === 'k') return true\r\n  \r\n          var offset = RAYS[index]\r\n          var j = i + offset\r\n  \r\n          var blocked = false\r\n          while (j !== square) {\r\n            if (board[j] != null) {\r\n              blocked = true\r\n              break\r\n            }\r\n            j += offset\r\n          }\r\n  \r\n          if (!blocked) return true\r\n        }\r\n      }\r\n  \r\n      return false\r\n    }\r\n  \r\n    function king_attacked(color) {\r\n      return attacked(swap_color(color), kings[color])\r\n    }\r\n  \r\n    function in_check() {\r\n      return king_attacked(turn)\r\n    }\r\n  \r\n    function in_checkmate() {\r\n      return (in_check() && generate_moves().length === 0) || !/(.*k.*)(.*K.*)*/.test(generate_fen());\r\n    }\r\n  \r\n    function in_stalemate() {\r\n      return !in_check() && generate_moves().length === 0\r\n    }\r\n  \r\n    function insufficient_material() {\r\n      var pieces = {}\r\n      var bishops = []\r\n      var num_pieces = 0\r\n      var sq_color = 0\r\n  \r\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\r\n        sq_color = (sq_color + 1) % 2\r\n        if (i & 0x88) {\r\n          i += 7\r\n          continue\r\n        }\r\n  \r\n        var piece = board[i]\r\n        if (piece) {\r\n          pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\r\n          if (piece.type === BISHOP) {\r\n            bishops.push(sq_color)\r\n          }\r\n          num_pieces++\r\n        }\r\n      }\r\n  \r\n      /* k vs. k */\r\n      if (num_pieces === 2) {\r\n        return true\r\n      } else if (\r\n        /* k vs. kn .... or .... k vs. kb */\r\n        num_pieces === 3 &&\r\n        (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\r\n      ) {\r\n        return true\r\n      } else if (num_pieces === pieces[BISHOP] + 2) {\r\n        /* kb vs. kb where any number of bishops are all on the same color */\r\n        var sum = 0\r\n        var len = bishops.length\r\n        for (var i = 0; i < len; i++) {\r\n          sum += bishops[i]\r\n        }\r\n        if (sum === 0 || sum === len) {\r\n          return true\r\n        }\r\n      }\r\n  \r\n      return false\r\n    }\r\n  \r\n    function in_threefold_repetition() {\r\n      /* TODO: while this function is fine for casual use, a better\r\n       * implementation would use a Zobrist key (instead of FEN). the\r\n       * Zobrist key would be maintained in the make_move/undo_move functions,\r\n       * avoiding the costly that we do below.\r\n       */\r\n      var moves = []\r\n      var positions = {}\r\n      var repetition = false\r\n  \r\n      while (true) {\r\n        var move = undo_move()\r\n        if (!move) break\r\n        moves.push(move)\r\n      }\r\n  \r\n      while (true) {\r\n        /* remove the last two fields in the FEN string, they're not needed\r\n         * when checking for draw by rep */\r\n        var fen = generate_fen().split(' ').slice(0, 4).join(' ')\r\n  \r\n        /* has the position occurred three or move times */\r\n        positions[fen] = fen in positions ? positions[fen] + 1 : 1\r\n        if (positions[fen] >= 3) {\r\n          repetition = true\r\n        }\r\n  \r\n        if (!moves.length) {\r\n          break\r\n        }\r\n        make_move(moves.pop())\r\n      }\r\n  \r\n      return repetition\r\n    }\r\n  \r\n    function push(move) {\r\n      history.push({\r\n        move: move,\r\n        kings: { b: kings.b, w: kings.w },\r\n        turn: turn,\r\n        castling: { b: castling.b, w: castling.w },\r\n        ep_square: ep_square,\r\n        half_moves: half_moves,\r\n        move_number: move_number,\r\n      })\r\n    }\r\n  \r\n    function make_move(move) {\r\n      var us = turn\r\n      var them = swap_color(us)\r\n      push(move)\r\n  \r\n      board[move.to] = board[move.from]\r\n      board[move.from] = null\r\n  \r\n      /* if ep capture, remove the captured pawn */\r\n      if (move.flags & BITS.EP_CAPTURE) {\r\n        if (turn === BLACK) {\r\n          board[move.to - 16] = null\r\n        } else {\r\n          board[move.to + 16] = null\r\n        }\r\n      }\r\n  \r\n      /* if pawn promotion, replace with new piece */\r\n      if (move.flags & BITS.PROMOTION) {\r\n        board[move.to] = { type: move.promotion, color: us }\r\n      }\r\n  \r\n      /* if we moved the king */\r\n      if (board[move.to].type === KING) {\r\n        kings[board[move.to].color] = move.to\r\n  \r\n        /* if we castled, move the rook next to the king */\r\n        if (move.flags & BITS.KSIDE_CASTLE) {\r\n          var castling_to = move.to - 1\r\n          var castling_from = move.to + 1\r\n          board[castling_to] = board[castling_from]\r\n          board[castling_from] = null\r\n        } else if (move.flags & BITS.QSIDE_CASTLE) {\r\n          var castling_to = move.to + 1\r\n          var castling_from = move.to - 2\r\n          board[castling_to] = board[castling_from]\r\n          board[castling_from] = null\r\n        }\r\n  \r\n        /* turn off castling */\r\n        castling[us] = ''\r\n      }\r\n  \r\n      /* turn off castling if we move a rook */\r\n      if (castling[us]) {\r\n        for (var i = 0, len = ROOKS[us].length; i < len; i++) {\r\n          if (\r\n            move.from === ROOKS[us][i].square &&\r\n            castling[us] & ROOKS[us][i].flag\r\n          ) {\r\n            castling[us] ^= ROOKS[us][i].flag\r\n            break\r\n          }\r\n        }\r\n      }\r\n  \r\n      /* turn off castling if we capture a rook */\r\n      if (castling[them]) {\r\n        for (var i = 0, len = ROOKS[them].length; i < len; i++) {\r\n          if (\r\n            move.to === ROOKS[them][i].square &&\r\n            castling[them] & ROOKS[them][i].flag\r\n          ) {\r\n            castling[them] ^= ROOKS[them][i].flag\r\n            break\r\n          }\r\n        }\r\n      }\r\n  \r\n      /* if big pawn move, update the en passant square */\r\n      if (move.flags & BITS.BIG_PAWN) {\r\n        if (turn === 'b') {\r\n          ep_square = move.to - 16\r\n        } else {\r\n          ep_square = move.to + 16\r\n        }\r\n      } else {\r\n        ep_square = EMPTY\r\n      }\r\n  \r\n      /* reset the 50 move counter if a pawn is moved or a piece is captured */\r\n      if (move.piece === PAWN) {\r\n        half_moves = 0\r\n      } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\r\n        half_moves = 0\r\n      } else {\r\n        half_moves++\r\n      }\r\n  \r\n      if (turn === BLACK) {\r\n        move_number++\r\n      }\r\n      turn = swap_color(turn)\r\n    }\r\n  \r\n    function undo_move() {\r\n      var old = history.pop()\r\n      if (old == null) {\r\n        return null\r\n      }\r\n  \r\n      var move = old.move\r\n      kings = old.kings\r\n      turn = old.turn\r\n      castling = old.castling\r\n      ep_square = old.ep_square\r\n      half_moves = old.half_moves\r\n      move_number = old.move_number\r\n  \r\n      var us = turn\r\n      var them = swap_color(turn)\r\n  \r\n      board[move.from] = board[move.to]\r\n      board[move.from].type = move.piece // to undo any promotions\r\n      board[move.to] = null\r\n  \r\n      if (move.flags & BITS.CAPTURE) {\r\n        board[move.to] = { type: move.captured, color: them }\r\n      } else if (move.flags & BITS.EP_CAPTURE) {\r\n        var index\r\n        if (us === BLACK) {\r\n          index = move.to - 16\r\n        } else {\r\n          index = move.to + 16\r\n        }\r\n        board[index] = { type: PAWN, color: them }\r\n      }\r\n  \r\n      if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\r\n        var castling_to, castling_from\r\n        if (move.flags & BITS.KSIDE_CASTLE) {\r\n          castling_to = move.to + 1\r\n          castling_from = move.to - 1\r\n        } else if (move.flags & BITS.QSIDE_CASTLE) {\r\n          castling_to = move.to - 2\r\n          castling_from = move.to + 1\r\n        }\r\n  \r\n        board[castling_to] = board[castling_from]\r\n        board[castling_from] = null\r\n      }\r\n  \r\n      return move\r\n    }\r\n  \r\n    /* this function is used to uniquely identify ambiguous moves */\r\n    function get_disambiguator(move, moves) {\r\n      var from = move.from\r\n      var to = move.to\r\n      var piece = move.piece\r\n  \r\n      var ambiguities = 0\r\n      var same_rank = 0\r\n      var same_file = 0\r\n  \r\n      for (var i = 0, len = moves.length; i < len; i++) {\r\n        var ambig_from = moves[i].from\r\n        var ambig_to = moves[i].to\r\n        var ambig_piece = moves[i].piece\r\n  \r\n        /* if a move of the same piece type ends on the same to square, we'll\r\n         * need to add a disambiguator to the algebraic notation\r\n         */\r\n        if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\r\n          ambiguities++\r\n  \r\n          if (rank(from) === rank(ambig_from)) {\r\n            same_rank++\r\n          }\r\n  \r\n          if (file(from) === file(ambig_from)) {\r\n            same_file++\r\n          }\r\n        }\r\n      }\r\n  \r\n      if (ambiguities > 0) {\r\n        /* if there exists a similar moving piece on the same rank and file as\r\n         * the move in question, use the square as the disambiguator\r\n         */\r\n        if (same_rank > 0 && same_file > 0) {\r\n          return algebraic(from)\r\n        } else if (same_file > 0) {\r\n          /* if the moving piece rests on the same file, use the rank symbol as the\r\n           * disambiguator\r\n           */\r\n          return algebraic(from).charAt(1)\r\n        } else {\r\n          /* else use the file symbol */\r\n          return algebraic(from).charAt(0)\r\n        }\r\n      }\r\n  \r\n      return ''\r\n    }\r\n  \r\n    function infer_piece_type(san) {\r\n      var piece_type = san.charAt(0)\r\n      if (piece_type >= 'a' && piece_type <= 'h') {\r\n        var matches = san.match(/[a-h]\\d.*[a-h]\\d/)\r\n        if (matches) {\r\n          return undefined\r\n        }\r\n        return PAWN\r\n      }\r\n      piece_type = piece_type.toLowerCase()\r\n      if (piece_type === 'o') {\r\n        return KING\r\n      }\r\n      return piece_type\r\n    }\r\n    function ascii() {\r\n      var s = '   +------------------------+\\n'\r\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\r\n        /* display the rank */\r\n        if (file(i) === 0) {\r\n          s += ' ' + '87654321'[rank(i)] + ' |'\r\n        }\r\n  \r\n        /* empty piece */\r\n        if (board[i] == null) {\r\n          s += ' . '\r\n        } else {\r\n          var piece = board[i].type\r\n          var color = board[i].color\r\n          var symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\r\n          s += ' ' + symbol + ' '\r\n        }\r\n  \r\n        if ((i + 1) & 0x88) {\r\n          s += '|\\n'\r\n          i += 8\r\n        }\r\n      }\r\n      s += '   +------------------------+\\n'\r\n      s += '     a  b  c  d  e  f  g  h\\n'\r\n  \r\n      return s\r\n    }\r\n  \r\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\r\n    function move_from_san(move, sloppy) {\r\n      // strip off any move decorations: e.g Nf3+?! becomes Nf3\r\n      var clean_move = stripped_san(move)\r\n  \r\n      var overly_disambiguated = false\r\n  \r\n      if (sloppy) {\r\n        // The sloppy parser allows the user to parse non-standard chess\r\n        // notations. This parser is opt-in (by specifying the\r\n        // '{ sloppy: true }' setting) and is only run after the Standard\r\n        // Algebraic Notation (SAN) parser has failed.\r\n        //\r\n        // When running the sloppy parser, we'll run a regex to grab the piece,\r\n        // the to/from square, and an optional promotion piece. This regex will\r\n        // parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7, f7f8q,\r\n        // b1c3\r\n  \r\n        // NOTE: Some positions and moves may be ambiguous when using the sloppy\r\n        // parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\r\n        // the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated\r\n        // bishop move). In these cases, the sloppy parser will default to the\r\n        // most most basic interpretation - b1c3 parses to Nc3.\r\n  \r\n        var matches = clean_move.match(\r\n          /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\r\n        )\r\n        if (matches) {\r\n          var piece = matches[1]\r\n          var from = matches[2]\r\n          var to = matches[3]\r\n          var promotion = matches[4]\r\n  \r\n          if (from.length == 1) {\r\n            overly_disambiguated = true\r\n          }\r\n        } else {\r\n          // The [a-h]?[1-8]? portion of the regex below handles moves that may\r\n          // be overly disambiguated (e.g. Nge7 is unnecessary and non-standard\r\n          // when there is one legal knight move to e7). In this case, the value\r\n          // of 'from' variable will be a rank or file, not a square.\r\n          var matches = clean_move.match(\r\n            /([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/\r\n          )\r\n  \r\n          if (matches) {\r\n            var piece = matches[1]\r\n            var from = matches[2]\r\n            var to = matches[3]\r\n            var promotion = matches[4]\r\n  \r\n            if (from.length == 1) {\r\n              var overly_disambiguated = true\r\n            }\r\n          }\r\n        }\r\n      }\r\n  \r\n      var piece_type = infer_piece_type(clean_move)\r\n      var moves = generate_moves({\r\n        legal: true,\r\n        piece: piece ? piece : piece_type,\r\n      })\r\n  \r\n      for (var i = 0, len = moves.length; i < len; i++) {\r\n        // try the strict parser first, then the sloppy parser if requested\r\n        // by the user\r\n        if (clean_move === stripped_san(move_to_san(moves[i], moves))) {\r\n          return moves[i]\r\n        } else {\r\n          if (sloppy && matches) {\r\n            // hand-compare move properties with the results from our sloppy\r\n            // regex\r\n            if (\r\n              (!piece || piece.toLowerCase() == moves[i].piece) &&\r\n              SQUARES[from] == moves[i].from &&\r\n              SQUARES[to] == moves[i].to &&\r\n              (!promotion || promotion.toLowerCase() == moves[i].promotion)\r\n            ) {\r\n              return moves[i]\r\n            } else if (overly_disambiguated) {\r\n              // SPECIAL CASE: we parsed a move string that may have an unneeded\r\n              // rank/file disambiguator (e.g. Nge7).  The 'from' variable will\r\n              var square = algebraic(moves[i].from)\r\n              if (\r\n                (!piece || piece.toLowerCase() == moves[i].piece) &&\r\n                SQUARES[to] == moves[i].to &&\r\n                (from == square[0] || from == square[1]) &&\r\n                (!promotion || promotion.toLowerCase() == moves[i].promotion)\r\n              ) {\r\n                return moves[i]\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n  \r\n      return null\r\n    }\r\n  \r\n    /*****************************************************************************\r\n     * UTILITY FUNCTIONS\r\n     ****************************************************************************/\r\n    function rank(i) {\r\n      return i >> 4\r\n    }\r\n  \r\n    function file(i) {\r\n      return i & 15\r\n    }\r\n  \r\n    function algebraic(i) {\r\n      var f = file(i),\r\n        r = rank(i)\r\n      return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1)\r\n    }\r\n  \r\n    function swap_color(c) {\r\n      return c === WHITE ? BLACK : WHITE\r\n    }\r\n  \r\n    function is_digit(c) {\r\n      return '0123456789'.indexOf(c) !== -1\r\n    }\r\n  \r\n    /* pretty = external move object */\r\n    function make_pretty(ugly_move) {\r\n      var move = clone(ugly_move)\r\n      move.san = move_to_san(move, generate_moves({ legal: true }))\r\n      move.to = algebraic(move.to)\r\n      move.from = algebraic(move.from)\r\n  \r\n      var flags = ''\r\n  \r\n      for (var flag in BITS) {\r\n        if (BITS[flag] & move.flags) {\r\n          flags += FLAGS[flag]\r\n        }\r\n      }\r\n      move.flags = flags\r\n  \r\n      return move\r\n    }\r\n  \r\n    function clone(obj) {\r\n      var dupe = obj instanceof Array ? [] : {}\r\n  \r\n      for (var property in obj) {\r\n        if (typeof property === 'object') {\r\n          dupe[property] = clone(obj[property])\r\n        } else {\r\n          dupe[property] = obj[property]\r\n        }\r\n      }\r\n  \r\n      return dupe\r\n    }\r\n  \r\n    function trim(str) {\r\n      return str.replace(/^\\s+|\\s+$/g, '')\r\n    }\r\n  \r\n    /*****************************************************************************\r\n     * DEBUGGING UTILITIES\r\n     ****************************************************************************/\r\n    function perft(depth) {\r\n      var moves = generate_moves({ legal: false })\r\n      var nodes = 0\r\n      var color = turn\r\n  \r\n      for (var i = 0, len = moves.length; i < len; i++) {\r\n        make_move(moves[i])\r\n        if (!king_attacked(color)) {\r\n          if (depth - 1 > 0) {\r\n            var child_nodes = perft(depth - 1)\r\n            nodes += child_nodes\r\n          } else {\r\n            nodes++\r\n          }\r\n        }\r\n        undo_move()\r\n      }\r\n  \r\n      return nodes\r\n    }\r\n  \r\n    return {\r\n      /***************************************************************************\r\n       * PUBLIC CONSTANTS (is there a better way to do this?)\r\n       **************************************************************************/\r\n      WHITE: WHITE,\r\n      BLACK: BLACK,\r\n      PAWN: PAWN,\r\n      KNIGHT: KNIGHT,\r\n      BISHOP: BISHOP,\r\n      ROOK: ROOK,\r\n      QUEEN: QUEEN,\r\n      KING: KING,\r\n      SQUARES: (function () {\r\n        /* from the ECMA-262 spec (section 12.6.4):\r\n         * \"The mechanics of enumerating the properties ... is\r\n         * implementation dependent\"\r\n         * so: for (var sq in SQUARES) { keys.push(sq); } might not be\r\n         * ordered correctly\r\n         */\r\n        var keys = []\r\n        for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\r\n          if (i & 0x88) {\r\n            i += 7\r\n            continue\r\n          }\r\n          keys.push(algebraic(i))\r\n        }\r\n        return keys\r\n      })(),\r\n      FLAGS: FLAGS,\r\n  \r\n      /***************************************************************************\r\n       * PUBLIC API\r\n       **************************************************************************/\r\n      load: function (fen) {\r\n        return load(fen)\r\n      },\r\n  \r\n      end_turn: function () {\r\n        end_turn();\r\n      },\r\n  \r\n      reset: function () {\r\n        return reset()\r\n      },\r\n  \r\n      moves: function (options) {\r\n        /* The internal representation of a chess move is in 0x88 format, and\r\n         * not meant to be human-readable.  The code below converts the 0x88\r\n         * square coordinates to algebraic coordinates.  It also prunes an\r\n         * unnecessary move keys resulting from a verbose call.\r\n         */\r\n  \r\n        var ugly_moves = generate_moves(options)\r\n        var moves = []\r\n  \r\n        for (var i = 0, len = ugly_moves.length; i < len; i++) {\r\n          /* does the user want a full move object (most likely not), or just\r\n           * SAN\r\n           */\r\n          if (\r\n            typeof options !== 'undefined' &&\r\n            'verbose' in options &&\r\n            options.verbose\r\n          ) {\r\n            moves.push(make_pretty(ugly_moves[i]))\r\n          } else {\r\n            moves.push(\r\n              move_to_san(ugly_moves[i], generate_moves({ legal: true }))\r\n            )\r\n          }\r\n        }\r\n  \r\n        return moves\r\n      },\r\n  \r\n      in_check: function () {\r\n        return in_check()\r\n      },\r\n  \r\n      in_checkmate: function () {\r\n        return in_checkmate()\r\n      },\r\n  \r\n      in_stalemate: function () {\r\n        return in_stalemate()\r\n      },\r\n  \r\n      in_draw: function () {\r\n        return (\r\n          half_moves >= 100 ||\r\n          in_stalemate() ||\r\n          insufficient_material() ||\r\n          in_threefold_repetition()\r\n        )\r\n      },\r\n  \r\n      insufficient_material: function () {\r\n        return insufficient_material()\r\n      },\r\n  \r\n      in_threefold_repetition: function () {\r\n        return in_threefold_repetition()\r\n      },\r\n  \r\n      game_over: function () {\r\n        return (\r\n          half_moves >= 100 ||\r\n          in_checkmate() ||\r\n          in_stalemate() ||\r\n          insufficient_material() ||\r\n          in_threefold_repetition()\r\n        )\r\n      },\r\n  \r\n      validate_fen: function (fen) {\r\n        return validate_fen(fen)\r\n      },\r\n  \r\n      fen: function () {\r\n        return generate_fen()\r\n      },\r\n  \r\n      board: function () {\r\n        var output = [],\r\n          row = []\r\n  \r\n        for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\r\n          if (board[i] == null) {\r\n            row.push(null)\r\n          } else {\r\n            row.push({ type: board[i].type, color: board[i].color })\r\n          }\r\n          if ((i + 1) & 0x88) {\r\n            output.push(row)\r\n            row = []\r\n            i += 8\r\n          }\r\n        }\r\n  \r\n        return output\r\n      },\r\n  \r\n      pgn: function (options) {\r\n        /* using the specification from http://www.chessclub.com/help/PGN-spec\r\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\r\n         */\r\n        var newline =\r\n          typeof options === 'object' && typeof options.newline_char === 'string'\r\n            ? options.newline_char\r\n            : '\\n'\r\n        var max_width =\r\n          typeof options === 'object' && typeof options.max_width === 'number'\r\n            ? options.max_width\r\n            : 0\r\n        var result = []\r\n        var header_exists = false\r\n  \r\n        /* add the PGN header headerrmation */\r\n        for (var i in header) {\r\n          /* TODO: order of enumerated properties in header object is not\r\n           * guaranteed, see ECMA-262 spec (section 12.6.4)\r\n           */\r\n          result.push('[' + i + ' \"' + header[i] + '\"]' + newline)\r\n          header_exists = true\r\n        }\r\n  \r\n        if (header_exists && history.length) {\r\n          result.push(newline)\r\n        }\r\n  \r\n        var append_comment = function (move_string) {\r\n          var comment = comments[generate_fen()]\r\n          if (typeof comment !== 'undefined') {\r\n            var delimiter = move_string.length > 0 ? ' ' : ''\r\n            move_string = `${move_string}${delimiter}{${comment}}`\r\n          }\r\n          return move_string\r\n        }\r\n  \r\n        /* pop all of history onto reversed_history */\r\n        var reversed_history = []\r\n        while (history.length > 0) {\r\n          reversed_history.push(undo_move())\r\n        }\r\n  \r\n        var moves = []\r\n        var move_string = ''\r\n  \r\n        /* special case of a commented starting position with no moves */\r\n        if (reversed_history.length === 0) {\r\n          moves.push(append_comment(''))\r\n        }\r\n  \r\n        /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\r\n        while (reversed_history.length > 0) {\r\n          move_string = append_comment(move_string)\r\n          var move = reversed_history.pop()\r\n  \r\n          /* if the position started with black to move, start PGN with 1. ... */\r\n          if (!history.length && move.color === 'b') {\r\n            move_string = move_number + '. ...'\r\n          } else if (move.color === 'w') {\r\n            /* store the previous generated move_string if we have one */\r\n            if (move_string.length) {\r\n              moves.push(move_string)\r\n            }\r\n            move_string = move_number + '.'\r\n          }\r\n  \r\n          move_string =\r\n            move_string + ' ' + move_to_san(move, generate_moves({ legal: true }))\r\n          make_move(move)\r\n        }\r\n  \r\n        /* are there any other leftover moves? */\r\n        if (move_string.length) {\r\n          moves.push(append_comment(move_string))\r\n        }\r\n  \r\n        /* is there a result? */\r\n        if (typeof header.Result !== 'undefined') {\r\n          moves.push(header.Result)\r\n        }\r\n  \r\n        /* history should be back to what it was before we started generating PGN,\r\n         * so join together moves\r\n         */\r\n        if (max_width === 0) {\r\n          return result.join('') + moves.join(' ')\r\n        }\r\n  \r\n        var strip = function () {\r\n          if (result.length > 0 && result[result.length - 1] === ' ') {\r\n            result.pop()\r\n            return true\r\n          }\r\n          return false\r\n        }\r\n  \r\n        /* NB: this does not preserve comment whitespace. */\r\n        var wrap_comment = function (width, move) {\r\n          for (var token of move.split(' ')) {\r\n            if (!token) {\r\n              continue\r\n            }\r\n            if (width + token.length > max_width) {\r\n              while (strip()) {\r\n                width--\r\n              }\r\n              result.push(newline)\r\n              width = 0\r\n            }\r\n            result.push(token)\r\n            width += token.length\r\n            result.push(' ')\r\n            width++\r\n          }\r\n          if (strip()) {\r\n            width--\r\n          }\r\n          return width\r\n        }\r\n  \r\n        /* wrap the PGN output at max_width */\r\n        var current_width = 0\r\n        for (var i = 0; i < moves.length; i++) {\r\n          if (current_width + moves[i].length > max_width) {\r\n            if (moves[i].includes('{')) {\r\n              current_width = wrap_comment(current_width, moves[i])\r\n              continue\r\n            }\r\n          }\r\n          /* if the current move will push past max_width */\r\n          if (current_width + moves[i].length > max_width && i !== 0) {\r\n            /* don't end the line with whitespace */\r\n            if (result[result.length - 1] === ' ') {\r\n              result.pop()\r\n            }\r\n  \r\n            result.push(newline)\r\n            current_width = 0\r\n          } else if (i !== 0) {\r\n            result.push(' ')\r\n            current_width++\r\n          }\r\n          result.push(moves[i])\r\n          current_width += moves[i].length\r\n        }\r\n  \r\n        return result.join('')\r\n      },\r\n  \r\n      load_pgn: function (pgn, options) {\r\n        // allow the user to specify the sloppy move parser to work around over\r\n        // disambiguation bugs in Fritz and Chessbase\r\n        var sloppy =\r\n          typeof options !== 'undefined' && 'sloppy' in options\r\n            ? options.sloppy\r\n            : false\r\n  \r\n        function mask(str) {\r\n          return str.replace(/\\\\/g, '\\\\')\r\n        }\r\n  \r\n        function has_keys(object) {\r\n          for (var key in object) {\r\n            return true\r\n          }\r\n          return false\r\n        }\r\n  \r\n        function parse_pgn_header(header, options) {\r\n          var newline_char =\r\n            typeof options === 'object' &&\r\n            typeof options.newline_char === 'string'\r\n              ? options.newline_char\r\n              : '\\r?\\n'\r\n          var header_obj = {}\r\n          var headers = header.split(new RegExp(mask(newline_char)))\r\n          var key = ''\r\n          var value = ''\r\n  \r\n          for (var i = 0; i < headers.length; i++) {\r\n            key = headers[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1')\r\n            value = headers[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\ *\\]$/, '$1')\r\n            if (trim(key).length > 0) {\r\n              header_obj[key] = value\r\n            }\r\n          }\r\n  \r\n          return header_obj\r\n        }\r\n  \r\n        var newline_char =\r\n          typeof options === 'object' && typeof options.newline_char === 'string'\r\n            ? options.newline_char\r\n            : '\\r?\\n'\r\n  \r\n        // RegExp to split header. Takes advantage of the fact that header and movetext\r\n        // will always have a blank line between them (ie, two newline_char's).\r\n        // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\r?\\n){2}/\r\n        var header_regex = new RegExp(\r\n          '^(\\\\[((?:' +\r\n            mask(newline_char) +\r\n            ')|.)*\\\\])' +\r\n            '(?:' +\r\n            mask(newline_char) +\r\n            '){2}'\r\n        )\r\n  \r\n        // If no header given, begin with moves.\r\n        var header_string = header_regex.test(pgn)\r\n          ? header_regex.exec(pgn)[1]\r\n          : ''\r\n  \r\n        // Put the board in the starting position\r\n        reset()\r\n  \r\n        /* parse PGN header */\r\n        var headers = parse_pgn_header(header_string, options)\r\n        for (var key in headers) {\r\n          set_header([key, headers[key]])\r\n        }\r\n  \r\n        /* load the starting position indicated by [Setup '1'] and\r\n         * [FEN position] */\r\n        if (headers['SetUp'] === '1') {\r\n          if (!('FEN' in headers && load(headers['FEN'], true))) {\r\n            // second argument to load: don't clear the headers\r\n            return false\r\n          }\r\n        }\r\n  \r\n        /* NB: the regexes below that delete move numbers, recursive\r\n         * annotations, and numeric annotation glyphs may also match\r\n         * text in comments. To prevent this, we transform comments\r\n         * by hex-encoding them in place and decoding them again after\r\n         * the other tokens have been deleted.\r\n         *\r\n         * While the spec states that PGN files should be ASCII encoded,\r\n         * we use {en,de}codeURIComponent here to support arbitrary UTF8\r\n         * as a convenience for modern users */\r\n  \r\n        var to_hex = function (string) {\r\n          return Array.from(string)\r\n            .map(function (c) {\r\n              /* encodeURI doesn't transform most ASCII characters,\r\n               * so we handle these ourselves */\r\n              return c.charCodeAt(0) < 128\r\n                ? c.charCodeAt(0).toString(16)\r\n                : encodeURIComponent(c).replace(/\\%/g, '').toLowerCase()\r\n            })\r\n            .join('')\r\n        }\r\n  \r\n        var from_hex = function (string) {\r\n          return string.length == 0\r\n            ? ''\r\n            : decodeURIComponent('%' + string.match(/.{1,2}/g).join('%'))\r\n        }\r\n  \r\n        var encode_comment = function (string) {\r\n          string = string.replace(new RegExp(mask(newline_char), 'g'), ' ')\r\n          return `{${to_hex(string.slice(1, string.length - 1))}}`\r\n        }\r\n  \r\n        var decode_comment = function (string) {\r\n          if (string.startsWith('{') && string.endsWith('}')) {\r\n            return from_hex(string.slice(1, string.length - 1))\r\n          }\r\n        }\r\n  \r\n        /* delete header to get the moves */\r\n        var ms = pgn\r\n          .replace(header_string, '')\r\n          .replace(\r\n            /* encode comments so they don't get deleted below */\r\n            new RegExp(`(\\{[^}]*\\})+?|;([^${mask(newline_char)}]*)`, 'g'),\r\n            function (match, bracket, semicolon) {\r\n              return bracket !== undefined\r\n                ? encode_comment(bracket)\r\n                : ' ' + encode_comment(`{${semicolon.slice(1)}}`)\r\n            }\r\n          )\r\n          .replace(new RegExp(mask(newline_char), 'g'), ' ')\r\n  \r\n        /* delete recursive annotation variations */\r\n        var rav_regex = /(\\([^\\(\\)]+\\))+?/g\r\n        while (rav_regex.test(ms)) {\r\n          ms = ms.replace(rav_regex, '')\r\n        }\r\n  \r\n        /* delete move numbers */\r\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '')\r\n  \r\n        /* delete ... indicating black to move */\r\n        ms = ms.replace(/\\.\\.\\./g, '')\r\n  \r\n        /* delete numeric annotation glyphs */\r\n        ms = ms.replace(/\\$\\d+/g, '')\r\n  \r\n        /* trim and get array of moves */\r\n        var moves = trim(ms).split(new RegExp(/\\s+/))\r\n  \r\n        /* delete empty entries */\r\n        moves = moves.join(',').replace(/,,+/g, ',').split(',')\r\n        var move = ''\r\n  \r\n        var result = ''\r\n  \r\n        for (var half_move = 0; half_move < moves.length; half_move++) {\r\n          var comment = decode_comment(moves[half_move])\r\n          if (comment !== undefined) {\r\n            comments[generate_fen()] = comment\r\n            continue\r\n          }\r\n  \r\n          move = move_from_san(moves[half_move], sloppy)\r\n  \r\n          /* invalid move */\r\n          if (move == null) {\r\n            /* was the move an end of game marker */\r\n            if (TERMINATION_MARKERS.indexOf(moves[half_move]) > -1) {\r\n              result = moves[half_move]\r\n            } else {\r\n              return false\r\n            }\r\n          } else {\r\n            /* reset the end of game marker if making a valid move */\r\n            result = ''\r\n            make_move(move)\r\n          }\r\n        }\r\n  \r\n        /* Per section 8.2.6 of the PGN spec, the Result tag pair must match\r\n         * match the termination marker. Only do this when headers are present,\r\n         * but the result tag is missing\r\n         */\r\n        if (result && Object.keys(header).length && !header['Result']) {\r\n          set_header(['Result', result])\r\n        }\r\n  \r\n        return true\r\n      },\r\n  \r\n      header: function () {\r\n        return set_header(arguments)\r\n      },\r\n  \r\n      ascii: function () {\r\n        return ascii()\r\n      },\r\n  \r\n      turn: function () {\r\n        return turn\r\n      },\r\n  \r\n      move: function (move, options) {\r\n        /* The move function can be called with in the following parameters:\r\n         *\r\n         * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\r\n         *\r\n         * .move({ from: 'h7', <- where the 'move' is a move object (additional\r\n         *         to :'h8',      fields are ignored)\r\n         *         promotion: 'q',\r\n         *      })\r\n         */\r\n  \r\n        // allow the user to specify the sloppy move parser to work around over\r\n        // disambiguation bugs in Fritz and Chessbase\r\n        var sloppy =\r\n          typeof options !== 'undefined' && 'sloppy' in options\r\n            ? options.sloppy\r\n            : false\r\n  \r\n        var move_obj = null\r\n  \r\n        if (typeof move === 'string') {\r\n          move_obj = move_from_san(move, sloppy)\r\n        } else if (typeof move === 'object') {\r\n          var moves = generate_moves()\r\n  \r\n          /* convert the pretty move object to an ugly move object */\r\n          for (var i = 0, len = moves.length; i < len; i++) {\r\n            if (\r\n              move.from === algebraic(moves[i].from) &&\r\n              move.to === algebraic(moves[i].to) &&\r\n              (!('promotion' in moves[i]) ||\r\n                move.promotion === moves[i].promotion)\r\n            ) {\r\n              move_obj = moves[i]\r\n              break\r\n            }\r\n          }\r\n        }\r\n  \r\n        /* failed to find move */\r\n        if (!move_obj) {\r\n          return null\r\n        }\r\n  \r\n        /* need to make a copy of move because we can't generate SAN after the\r\n         * move is made\r\n         */\r\n        var pretty_move = make_pretty(move_obj)\r\n  \r\n        make_move(move_obj)\r\n  \r\n        return pretty_move\r\n      },\r\n  \r\n      undo: function () {\r\n        var move = undo_move()\r\n        return move ? make_pretty(move) : null\r\n      },\r\n  \r\n      clear: function () {\r\n        return clear()\r\n      },\r\n  \r\n      put: function (piece, square) {\r\n        return put(piece, square)\r\n      },\r\n  \r\n      get: function (square) {\r\n        return get(square)\r\n      },\r\n  \r\n      remove: function (square) {\r\n        return remove(square)\r\n      },\r\n  \r\n      perft: function (depth) {\r\n        return perft(depth)\r\n      },\r\n  \r\n      square_color: function (square) {\r\n        if (square in SQUARES) {\r\n          var sq_0x88 = SQUARES[square]\r\n          return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? 'light' : 'dark'\r\n        }\r\n  \r\n        return null\r\n      },\r\n  \r\n      history: function (options) {\r\n        var reversed_history = []\r\n        var move_history = []\r\n        var verbose =\r\n          typeof options !== 'undefined' &&\r\n          'verbose' in options &&\r\n          options.verbose\r\n  \r\n        while (history.length > 0) {\r\n          reversed_history.push(undo_move())\r\n        }\r\n  \r\n        while (reversed_history.length > 0) {\r\n          var move = reversed_history.pop()\r\n          if (verbose) {\r\n            move_history.push(make_pretty(move))\r\n          } else {\r\n            move_history.push(move_to_san(move, generate_moves({ legal: true })))\r\n          }\r\n          make_move(move)\r\n        }\r\n  \r\n        return move_history\r\n      },\r\n  \r\n      get_comment: function () {\r\n        return comments[generate_fen()]\r\n      },\r\n  \r\n      set_comment: function (comment) {\r\n        comments[generate_fen()] = comment.replace('{', '[').replace('}', ']')\r\n      },\r\n  \r\n      delete_comment: function () {\r\n        var comment = comments[generate_fen()]\r\n        delete comments[generate_fen()]\r\n        return comment\r\n      },\r\n  \r\n      get_comments: function () {\r\n        prune_comments()\r\n        return Object.keys(comments).map(function (fen) {\r\n          return { fen: fen, comment: comments[fen] }\r\n        })\r\n      },\r\n  \r\n      delete_comments: function () {\r\n        prune_comments()\r\n        return Object.keys(comments).map(function (fen) {\r\n          var comment = comments[fen]\r\n          delete comments[fen]\r\n          return { fen: fen, comment: comment }\r\n        })\r\n      },\r\n    }\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}